var documenterSearchIndex = {"docs":
[{"location":"#CodingTheory.jl-Documentation","page":"Index","title":"CodingTheory.jl Documentation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"","category":"page"},{"location":"","page":"Index","title":"Index","text":"CurrentModule = CodingTheory\nDocTestSetup = quote\n    using CodingTheory\nend","category":"page"},{"location":"#Adding-CodingTheory.jl","page":"Index","title":"Adding CodingTheory.jl","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"using Pkg\nPkg.add(\"CodingTheory\")","category":"page"},{"location":"#Documentation","page":"Index","title":"Documentation","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"Modules = [CodingTheory]","category":"page"},{"location":"#Main.CodingTheory.AbstractWord","page":"Index","title":"Main.CodingTheory.AbstractWord","text":"AbstractWord{N} = Union{NonStaticAbstractWord{N, T}, MVector{T}} where {T}\n\n\n\n\n\n","category":"type"},{"location":"#Main.CodingTheory.NonStaticAbstractWord","page":"Index","title":"Main.CodingTheory.NonStaticAbstractWord","text":"NonStaticAbstractWord{N, T} = Union{NTuple{N, T}, AbstractVector{T}, AbstractString} where {N, T}\n\n\n\n\n\n","category":"type"},{"location":"#Main.CodingTheory.AbstractCode","page":"Index","title":"Main.CodingTheory.AbstractCode","text":"abstract type AbstractCode end\n\n\n\n\n\n","category":"type"},{"location":"#Main.CodingTheory.Alphabet","page":"Index","title":"Main.CodingTheory.Alphabet","text":"struct Alphabet <: AbstractCode\n\nHas the parameter Œ£, which is the alphabet; a collection of strings, characters, symbols, or Ints.\n\n\n\nAlphabet(Œ£::AbstractArray)\n\nA constructor method for the struct Alphabet.  Takes an array of letters in the alphabet, and attempts to parse them as 64-bit Ints.\n\n\n\nAlphabet{N}(Œ£::AbstractArray)\nAlphabet{N}(Œ£::AbstractString)\n\nA constructor method for the struct Alphabet.  Takes in a symbols and splits it into constituent characters.  Those symbols are the letters in the alphabet.  N is the number of letters in the alphabet\n\n\n\n\n\n","category":"type"},{"location":"#Main.CodingTheory.CodeUniverse","page":"Index","title":"Main.CodingTheory.CodeUniverse","text":"struct CodeUniverse <: AbstractCode\n\nDefines a structure for the messages in the code.  Parameters are the abstract array of messages ùí∞, and the length of the messages n.\n\nCodeUniverse(ùí∞::AbstractArray, Œ£::Alphabet)\n\nAn inner constructor function on the structure CodeUniverse.\n\n\n\n\n\n","category":"type"},{"location":"#Main.CodingTheory.CodeUniverseIterator","page":"Index","title":"Main.CodingTheory.CodeUniverseIterator","text":"struct CodeUniverseIterator <: AbstractCode\n\nA structure used to iterate through a code universe, with specified universe parameters.  E.g.,\n\nfor c in CodeUniverseIterator([\"a\", \"b\", \"c\"], 3)\n    println(c)\nend\n\nFields:\n\nùí∞::UniverseParameters\n\nMethods:\n\nCodeUniverseIterator(ùí∞::UniverseParameters)\nCodeUniverseIterator(Œ£::Union{Alphabet, AbstractArray}, q::Int, n::Int)\nCodeUniverseIterator(Œ£::Union{Alphabet, AbstractArray}, n::Int)\nCodeUniverseIterator(q::Int, n::Int)\n\n\n\n\n\n","category":"type"},{"location":"#Main.CodingTheory.Codewords","page":"Index","title":"Main.CodingTheory.Codewords","text":"Codewords{N} <: AbstractCode\n\nSimply a wrapper type for a vector of abstract words of length N.\n\n\n\n\n\n","category":"type"},{"location":"#Main.CodingTheory.FiniteField","page":"Index","title":"Main.CodingTheory.FiniteField","text":"abstract type FiniteField end\n\n\n\n\n\n","category":"type"},{"location":"#Main.CodingTheory.FinitePolynomial","page":"Index","title":"Main.CodingTheory.FinitePolynomial","text":"struct FinitePolynomial <: FiniteField\n\nHas parameters p, which is an abstract polynomial, and n which is the modulus of the field under which the molynomial is defined.\n\n\n\nFinitePolynomial(p::AbstractPolynomial, n::Int)\n\nA constructor method for FinitePolynomial.  Takes in a polynomial p and a number n, and constructs a polynomial under modulo n.\n\n\n\n\n\n","category":"type"},{"location":"#Main.CodingTheory.Rounding","page":"Index","title":"Main.CodingTheory.Rounding","text":"struct Rounding end\n\nAn abstract structure used as a parameter in a non-rounding method of hamming_bound.  Use no_round for this; a predefiend variable of the structure Rounding.\n\n\n\n\n\n","category":"type"},{"location":"#Main.CodingTheory.UniverseParameters","page":"Index","title":"Main.CodingTheory.UniverseParameters","text":"struct UniverseParameters <: AbstractCode\n\nDefines a structure for the messages in the code.  Parameters are the alphabet Œ£, size of alphabet q, and block length n\n\nUniverseParameters(Œ£::Alphabet, n::Int)\nUniverseParameters(Œ£::AbstractArray, n::Int)\nUniverseParameters(Œ£::Alphabet, q::Int, n::Int)\nUniverseParameters(Œ£::AbstractArray, q::Int, n::Int)\nUniverseParameters(q::Int, n::Int)\n\nAn inner constructor function on the structure UniverseParameters.\n\n\n\n\n\n","category":"type"},{"location":"#Main.CodingTheory.Word","page":"Index","title":"Main.CodingTheory.Word","text":"mutable struct Word{N, T}\nWord(w::NTuple{N, T})\nWord(w::AbstractVector{T})\nWord(w::AbstractString)\nWord(i::T...)\n\nA Word is an StaticArrays.MVector which is efficient (like tuple) yet mutable.\n\n\n\n\n\n","category":"type"},{"location":"#Polynomials.Polynomial-Union{Tuple{T}, Tuple{N}, Tuple{Union{Array{T,1}, Tuple{Vararg{T,N}}},Int64}} where T where N","page":"Index","title":"Polynomials.Polynomial","text":"Polynomial(A::Union{NTuple{N, T}, Vector{T}}, n::Int) -> Polynomial\n\nConstructs a polynomial under modulo n.\n\nParameters:\n\nA::Union{Tuple, AbstractArray}: The polynomial coefficients.\nn::Int: The modulus of the field.\n\nReturns\n\nPolynomial: A polynomial modulo n.\n\n\n\n\n\n","category":"method"},{"location":"#Base.gensym-Tuple{Int64}","page":"Index","title":"Base.gensym","text":"gensym(q::Int) -> Vector{Symbol}\n\nGenerates a vector of unique symbols of length q.\n\n\n\n\n\n","category":"method"},{"location":"#Base.mod-Tuple{Polynomials.Polynomial,Int64}","page":"Index","title":"Base.mod","text":"mod(p::Polynomial, n::Int) -> Polynomial\n\nUses the FinitePolynomial constructor to return a polynomial p under modulus n.\n\nParameters:\n\np::Polynomial: The input polynomial.\nn::Int: The modulus of the field.\n\nReturns\n\nPolynomial: A polynomial modulo n.\n\n\n\n\n\n","category":"method"},{"location":"#Base.rand-Tuple{UniverseParameters,AbstractArray}","page":"Index","title":"Base.rand","text":"rand(ùí∞::UniverseParameters, C::AbstractArray) -> Tuple\n\nGiven universe parameters ùí∞ and a code C, return a tuple including\n\nA random word in C;\nA random letter in the alphabet; and\nA random index in the block length.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory._has_identity-Union{Tuple{T}, Tuple{Array{T,2} where T,Union{AbstractRange{T}, Base.OneTo{T}, T}}} where T<:Integer","page":"Index","title":"Main.CodingTheory._has_identity","text":"_has_identity(M::Matrix, n::Union{T, Base.OneTo{T}, AbstractRange{T}}) where {T <: Integer}\n\nInner function on has_identity function.  Will return a tuple of:\n\nWhether or not the matrix has an identity;\nWhere that identity matrix starts; and\nHow big the identity matrix is.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.allequal-Union{Tuple{Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}, Tuple{T}} where T","page":"Index","title":"Main.CodingTheory.allequal","text":"allequal(A) -> Bool\nallequal(a, b...) -> Bool\n\nCheck that all elements in a list are equal to each other.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.allequal_length-Union{Tuple{Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}, Tuple{T}} where T","page":"Index","title":"Main.CodingTheory.allequal_length","text":"allequal_length(A) -> Bool\nallequal_length(a, b...) -> Bool\n\nCheck that all elements in a list are of equal length.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.aredistinct-Union{Tuple{Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}, Tuple{T}} where T","page":"Index","title":"Main.CodingTheory.aredistinct","text":"aredistinct(A) -> Bool\naredistinct(a, b...) -> Bool\n\nCheck that all elements in a list are distinct from every other element in the list.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.areequalto-Union{Tuple{T}, Tuple{Any,Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}} where T","page":"Index","title":"Main.CodingTheory.areequalto","text":"areequalto(x::Number, A::AbstractArray) -> Bool\nareequalto(x::Number, a, b...) -> Bool\n\nCheck that all elements in a list are equal to a given x.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.arelessthan-Union{Tuple{T}, Tuple{Number,Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}} where T","page":"Index","title":"Main.CodingTheory.arelessthan","text":"arelessthan(x::Number, A) -> Bool\narelessthan(x::Number, a, b...) -> Bool\n\nCheck that all elements in a list are less than a given x.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.code_distance!-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,T}} where T<:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)","page":"Index","title":"Main.CodingTheory.code_distance!","text":"code_distance!(C::AbstractArray{T}, w::T) -> Int\n\nA wrapper to get the code distance after pushing a word to the code.  This directly changes the matrix M.  Use code_distance for a non-mutating version of this function.\n\nParameters:\n\nC::AbstractArray: An array of words in the code.\nw: A word to be appended to C.\n\nReturns:\n\nInt: The code distance after adding w to C.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.code_distance-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T<:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)","page":"Index","title":"Main.CodingTheory.code_distance","text":"code_distance(C::AbstractArray) -> Int\n\nFinds the distance of the code.  That is, given a code C, finds the minimum distance between any two words in the code, which are not the same. (Find the minimum hamming distance in the code for all unique letters).\n\nParameters:\n\nC::AbstractArray: An array of words in the code.\n\nReturn:\n\nInt: the distance of the code.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.code_distance-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,T}} where T<:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)","page":"Index","title":"Main.CodingTheory.code_distance","text":"code_distance(C::AbstractArray{T}, w::T) -> Int\n\nA wrapper to get the code distance after pushing a word to the code.\n\nParameters:\n\nC::AbstractArray: An array of words in the code.\nw: A word to be appended to C.\n\nReturns:\n\nInt: The code distance after adding w to C.\n\n\n\nExamples\n\njulia> code_distance([[0,0,0,0,0],[1,0,1,0,1],[0,1,0,1,0],[1,1,1,1,1]]) # gets the minimum distance between two vectors in an array of vectors\n2\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.construct_ham_matrix-Tuple{Int64,Int64}","page":"Index","title":"Main.CodingTheory.construct_ham_matrix","text":"construct_ham_matrix(r::Int, q::Int) -> Matrix\n\nConstruct a Hamming parity-check matrix.\n\nParameters:\n\nr::Int: number of rows of a parity check matrix.\nq:::Int: The size of the alphabet of the code.\n\nReturns:\n\nMatrix: The Hamming matrix, denoted as textHam(r q)\n\n\n\nExamples\n\njulia> construct_ham_matrix(3,2)\n3√ó7 Array{Int64,2}:\n 0  0  0  1  1  1  1\n 0  1  1  0  0  1  1\n 1  0  1  0  1  0  1\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.deepeltype-Tuple{Any}","page":"Index","title":"Main.CodingTheory.deepeltype","text":"deepeltype(a::AbstractArray) -> Type\n\nReturns the type of the inner-most element in a nested array structure.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.deepsym-Tuple{Any}","page":"Index","title":"Main.CodingTheory.deepsym","text":"deepsym(a::AbstractArray)\n\nConvert inner-most elements into symbols\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.displaymatrix-Tuple{AbstractArray}","page":"Index","title":"Main.CodingTheory.displaymatrix","text":"displaymatrix(M::AbstractArray)\n\nDisplays a matrix M in a compact form from the terminal.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.ensure_symbolic!-Tuple{Any}","page":"Index","title":"Main.CodingTheory.ensure_symbolic!","text":"ensure_symbolic!(Œ£) -> typeof(Œ£)\n\nEnsures that the inner-most elements of a nested array structure are of the type Symbol.  This is a mutating function.  Use its twin, non-mutating function, ensure_symbolic, if you need a non-mutating version of this.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.ensure_symbolic-Tuple{Any}","page":"Index","title":"Main.CodingTheory.ensure_symbolic","text":"ensure_symbolic(Œ£) -> typeof(Œ£)\n\nEnsures that the inner-most elements of a nested array structure are of the type Symbol.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.equivalent_code!-Tuple{AbstractArray{Int64,N} where N,Int64}","page":"Index","title":"Main.CodingTheory.equivalent_code!","text":"equivalent_code!(M::AbstractArray{Int}, n::Int) -> Matrix{Int}\n\nPeforms Gauss-Jordan elimination on a matrix M, but allows for column swapping.  This constructs an \"equivalent\" matrix.  This directly changes the matrix M.  Use equivalent_code for a non-mutating version of this function.\n\nParameters:\n\nM::AbstractArray{Int}: A matrix of Ints.\nn::Int: The modulus of the finite field.\n\nReturns:\n\nMatrix{Int}: A which represents an \"equivalent\" code to that of the matrix M.\n\n\n\nExamples\n\njulia> equivalent_code!([1 2 0 1 2 1 2; 2 2 2 0 1 1 1; 1 0 1 1 2 1 2; 0 1 0 1 1 2 2], 3) # computes rref colswap = true\n4√ó7 Array{Int64,2}:\n1  0  0  0  2  2  2\n0  1  0  0  2  0  1\n0  0  1  0  1  0  2\n0  0  0  1  2  2  1\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.equivalent_code-Tuple{AbstractArray{Int64,N} where N,Int64}","page":"Index","title":"Main.CodingTheory.equivalent_code","text":"equivalent_code(M::AbstractArray{Int}, n::Int) -> Matrix{Int}\n\nPeforms Gauss-Jordan elimination on a matrix M, but allows for column swapping.\n\nParameters:\n\nM::AbstractArray{Int}: A matrix of Ints.\nn::Int: The modulus of the finite field.\n\nReturns:\n\nMatrix{Int}: A which represents an \"equivalent\" code to that of the matrix M.\n\n\n\nExamples\n\njulia> equivalent_code([1 2 0 1 2 1 2; 2 2 2 0 1 1 1; 1 0 1 1 2 1 2; 0 1 0 1 1 2 2], 3) # computes rref colswap = true\n4√ó7 Array{Int64,2}:\n1  0  0  0  2  2  2\n0  1  0  0  2  0  1\n0  0  1  0  1  0  2\n0  0  0  1  2  2  1\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.find_error_correction_max-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T<:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}","page":"Index","title":"Main.CodingTheory.find_error_correction_max","text":"find_error_correction_max(C::AbstractArray{T}, modulo::Int) -> Int\n\nFinds the greatest number t such that C is error t error correcting.\n\nParameters:\n\nC::AbstractArray: An array of words in the code.\nmoldulo::Int: The modulus of the finite field.  The upper bound of t.\n\nReturns:\n\nInt: The maximum number t such that the code is t error correcting.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.find_error_detection_max-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T<:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}","page":"Index","title":"Main.CodingTheory.find_error_detection_max","text":"find_error_detection_max(C::AbstractArray{T}, modulo::Int) -> Int\n\nFinds the greatest number t such that C is error t error detecting.\n\nParameters:\n\nC::AbstractArray: An array of words in the code.\nmoldulo::Int: The modulus of the finite field.  The upper bound of t.\n\nReturns:\n\nInt: The maximum number t such that the code is t error detecting.\n\n\n\njulia> find_error_detection_max([[0, 0, 0, 0], [0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1]], 2)\n1\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.genalphabet-Tuple{Int64}","page":"Index","title":"Main.CodingTheory.genalphabet","text":"genalphabet(q::Int)\n\nGenerates an alphabet of q unique symbols.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.generator!-Tuple{AbstractArray{Int64,N} where N,Int64}","page":"Index","title":"Main.CodingTheory.generator!","text":"generator!(M::AbstractArray{Int}, n::Int; colswap::Bool = true) -> Matrix{Int}\n\nConstructs a generator matrix of the code, depending on if you allow for column swapping or not.   This function uses normal_form! or equivalent_code!.  This directly changes the matrix M.  Use generator for a non-mutating version of this function.\n\nParameters:\n\nM::AbstractArray{Int}: A matrix of Ints.\nn::Int: The modulus of the finite field.\ncolswap::Bool (kwarg): A boolean flag indicating whether or not you allow for swapping of columns when constructing the generating matrix.\n\nReturns:\n\nMatrix{Int}: A generating matrix.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.generator-Tuple{AbstractArray{Int64,N} where N,Int64}","page":"Index","title":"Main.CodingTheory.generator","text":"generator(M::AbstractArray{Int}, n::Int; colswap::Bool = true) -> Matrix{Int}\n\nConstructs a generator matrix of the code, depending on if you allow for column swapping or not.  This function uses normal_form or equivalent_code.\n\nParameters:   -M::AbstractArray{Int}: A matrix of Ints.\n\nn::Int: The modulus of the finite field.\ncolswap::Bool (kwarg): A boolean flag indicating whether or not you allow for swapping of columns when constructing the generating matrix.\n\nReturns:\n\nMatrix{Int}: A generating matrix.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.get_all_words-Union{Tuple{N}, Tuple{Alphabet{N},Int64,Int64}} where N","page":"Index","title":"Main.CodingTheory.get_all_words","text":"get_all_words(Œ£::Alphabet{N}, q::Int, n::Int) -> Codewords{M}\nget_all_words(Œ£::Alphabet{N}, n::Int) -> Codewords{M}\nget_all_words(Œ£::AbstractArray, q::Int, n::Int) -> Codewords{M}\nget_all_words(Œ£::AbstractArray, n::Int) -> Codewords{M}\nget_all_words(q::Int, n::Int) -> Codewords{M}\n\nGet the universe of all codewords of a given alphabet.  The alphabet will be uniquely generated if none is given.\n\nParameters:\n\nŒ£::AbstractArray: The alphabet allowed.\nq::Int: The size of the alphabet.\nn::Int: The (fixed) length of the words in the code.\nd::Int: The minimum distance between words in the code.\nùí∞::AbstractArray: The universe of all codewords of q many letters of block length n.\n\nReturns:\n\nCodewords{M}: An array of codewords, each of length M.  Each codewords is a tuple, and each character in said word is a symbol.\n\n\n\nExamples\n\njulia> get_all_words(2, 2) # all words of block length 2 using 2 unique symbols\n2√ó2 Array{Tuple{Symbol,Symbol},2}:\n (Symbol(\"##254\"), Symbol(\"##254\"))  (Symbol(\"##254\"), Symbol(\"##253\"))\n (Symbol(\"##253\"), Symbol(\"##254\"))  (Symbol(\"##253\"), Symbol(\"##253\"))\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.get_codewords-Tuple{AbstractArray,Int64}","page":"Index","title":"Main.CodingTheory.get_codewords","text":"get_codewords(G::AbstractArray, m::Int) -> Codewords{M}\n\nGet codewords of a code from the generating matrix under a finite field of modulo m.  Precisely, computes all linear combinations of the rows of the generating matrix.\n\nParameters:\n\nG::AbstractArray: A matrix of Ints which generates the code.\nm::Int: The bounds of the finite field (i.e., the molulus you wish to work in).\n\nReturns:\n\nCodewords{M}: An array of codewords, each of length M.  Each codewords is a tuple, and each character in said word is a symbol.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.get_codewords-Tuple{UniverseParameters,Int64}","page":"Index","title":"Main.CodingTheory.get_codewords","text":"get_codewords(ùí∞::UniverseParameters, d::Int; m::Int=10, m_random::Int = 1000) -> Codewords{M}\nget_codewords(Œ£::Alphabet{N}, q::Int, n::Int, d::Int; m::Int=10, m_random::Int=1000) -> Codewords{M}\nget_codewords(q::Int, n::Int, d::Int; m::Int=10, m_random::Int=1000) -> Codewords{M}\nget_codewords(q::Int, n::Int, d::Int; m::Int=10, m_random::Int=1000) -> Codewords{M}\nget_codewords(Œ£::AbstractArray, q::Int, n::Int, d::Int; m::Int=10, m_random::Int=1000) -> Codewords{M}\nget_codewords(Œ£::AbstractArray, n::Int, d::Int; m::Int=10, m_random::Int=1000) -> Codewords{M}\nget_codewords(Œ£::AbstractArray, q::Int, n::Int, d::Int, ùí∞::AbstractArray; m::Int=10, m_random::Int=1000) -> Codewords{M}\n\nUse function get_codewords_random m many times (with get_codewords_random(..., m = m_random)), and get_codewords_greedy.  Return the code with the greatest number of words.  The alphabet will be uniquely generated if none is given.  You can omit Œ£ and ùí∞.  You can omit q if Œ£ is given.\n\nParameters:\n\nŒ£::AbstractArray: The alphabet allowed.\nq::Int: The size of the alphabet.\nn::Int: The (fixed) length of the words in the code.\nd::Int: The minimum distance between words in the code.\nùí∞::AbstractArray: The universe of all codewords of q many letters of block length n.\nm::Int (kwarg): Try a random code m many times.\nm_random::Int (kwarg): The number of possible words get_codewords_random chooses from for each word it selects.\n\nReturns:\n\nCodewords{M}: An array of codewords, each of length M.  Each codewords is a tuple, and each character in said word is a symbol.\n\nnote: Note\n\n\n*If you are looking for a _maximal_ code, this is likely the function you need.*  Increasing `m` and `m_random` arbitrarily should ensure a maximal code‚Äî_however_, that computing power/time in not always possible, as it requires a lot of RAM to store certain codes in memeory.  Efforts are being made to make this process better by using memory-mapped filed instead of storing codewords in RAM, but this will make it much slower as well.  Help with this would be much appreciated.\n\n\n\nExamples\n\njulia> get_codewords([\"a\", \"b\", \"c\"], 3, 2) # get codewords of block length 3 with distance 2.  Once again, are symbols for uniqueness\n9-element Array{Tuple{Symbol,Symbol,Symbol},1}:\n (:a, :b, :a)\n (:c, :a, :b)\n (:b, :c, :c)\n (:b, :a, :a)\n (:c, :b, :c)\n (:a, :a, :c)\n (:a, :c, :b)\n (:c, :c, :a)\n (:b, :b, :b)\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.get_codewords_greedy-Tuple{UniverseParameters,Int64}","page":"Index","title":"Main.CodingTheory.get_codewords_greedy","text":"get_codewords_greedy(ùí∞::UniverseParameters, d::Int) -> Codewords{M}\nget_codewords_greedy(Œ£::Alphabet{N}, q::Int, n::Int, d::Int) -> Codewords{M}\nget_codewords_greedy(Œ£::Alphabet{N}, n::Int, d::Int) -> Codewords{M}\nget_codewords_greedy(q::Int, n::Int, d::Int) -> Codewords{M}\nget_codewords_greedy(Œ£::AbstractArray, q::Int, n::Int, d::Int) -> Codewords{M}\nget_codewords_greedy(Œ£::AbstractArray, n::Int, d::Int) -> Codewords{M}\nget_codewords_greedy(Œ£::AbstractArray, q::Int, n::Int, d::Int, ùí∞::AbstractArray) -> Codewords{M}\n\nSearch through the universe of all codewords and find a code of block length n and distance d, using the alphabet Œ£.  The alphabet will be uniquely generated if none is given.  This uses a greedy algorithm, simply iterating through all words (see above) and choosing them if they fit in the code.  In some cases the greedy algorithm is the best, but in others it is very much not.\n\nParameters:\n\nùí∞::UniverseParameters: The parameters of the universe of all codewords of q many letters of block length n.\nŒ£::AbstractArray: The alphabet allowed.\nq::Int: The size of the alphabet.\nn::Int: The (fixed) length of the words in the code.\nd::Int: The minimum distance between words in the code.\n\nReturns:\n\nCodewords{M}: An array of codewords, each of length M.  Each codewords is a tuple, and each character in said word is a symbol.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.get_codewords_random-Tuple{UniverseParameters,Int64}","page":"Index","title":"Main.CodingTheory.get_codewords_random","text":"get_codewords_random(ùí∞::UniverseParameters, d::Int; m::Int = 1000) -> Codewords{M}\nget_codewords_random(Œ£::Alphabet{N}, q::Int, n::Int, d::Int; m::Int=1000) -> Codewords{M}\nget_codewords_random(Œ£::Alphabet{N}, n::Int, d::Int; m::Int=1000)\t-> Codewords{M}\nget_codewords_random(q::Int, n::Int, d::Int; m::Int=1000) -> Codewords{M}\nget_codewords_random(Œ£::AbstractArray, q::Int, n::Int, d::Int; m::Int=1000) -> Codewords{M}\nget_codewords_random(Œ£::AbstractArray, n::Int, d::Int; m::Int=1000) -> Codewords{M}\nget_codewords_random(Œ£::AbstractArray, q::Int, n::Int, d::Int, ùí∞::AbstractArray; m::Int=1000) -> Codewords{M}\n\nSearch through the universe of all codewords at random and find a code of block length n and distance d, using the alphabet Œ£.  The alphabet will be uniquely generated if none is given.  This is a cleverer algorithm than the greedy algorithm.  Increasing the m keyword argument arbitrarily should produce a maximal code, as for each codeword it chooses, it collects a list of m many random words, and chooses the best one from that intermediate list.\n\nParameters:\n\nŒ£::AbstractArray: The alphabet allowed.\nq::Int: The size of the alphabet.\nn::Int: The (fixed) length of the words in the code.\nd::Int: The minimum distance between words in the code.\nùí∞::AbstractArray: The universe of all codewords of q many letters of block length n.\n\nReturns:\n\nCodewords{M}: An array of codewords, each of length M.  Each codewords is a tuple, and each character in said word is a symbol.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.hamming_ball-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Array{S,1},Int64}} where S where T<:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)","page":"Index","title":"Main.CodingTheory.hamming_ball","text":"hamming_ball(Œ£‚Åø::AbstractArray, w::Vector, e::Int) -> Vector{Vector}\n\nGet the codewords of radius e of a ball centered at word w.  That is, all words whose distance from w is less than or equal to the radius.\n\nParameters:\n\nŒ£‚Åø::AbstractArray: An array of words in the code.\nw::Vector: A word.\ne::Int: The radius of the ball.\n\nReturns:\n\nAbstractArray: The list of words in Œ£‚Åø whose distance from w is less than or equal to e.  Returns an array of array of symbols.\n\n\n\nExamples\n\njulia> hamming_ball([[1, 0, 1], [0, 1, 1], [1, 0, 0]], [1, 0, 0], 2) # given a list of words, a word, and a distance e (respectively), calculate all the words in the alphabet within distance e of that word.  Converts to symbols in order to keep unique lengths\n2-element Array{Any,1}:\n [Symbol(\"1\"), Symbol(\"0\"), Symbol(\"1\")]\n [Symbol(\"1\"), Symbol(\"0\"), Symbol(\"0\")]\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.hamming_distance-Union{Tuple{T}, Tuple{T,T}} where T<:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)","page":"Index","title":"Main.CodingTheory.hamming_distance","text":"hamming_distance(w‚ÇÅ, w‚ÇÇ) -> Int\n\nThe Hamming distance of two words is the number of changes that need to be made to each letter in the word for the words to be the same.  This does not work for words of unequal length.\n\nParameters:\n\nw‚ÇÅ: A word.\nw‚ÇÇ: Another word.\n\nReturns:\n\nInt: the number of changes needing to be made to one word for it to be identical to the other.\n\n\n\nExamples\n\njulia> hamming_distance(\"ABC\", \"BBC\") # computes the hamming distance\n1\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.hamming_sphere-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Array{S,1},Int64}} where S where T<:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)","page":"Index","title":"Main.CodingTheory.hamming_sphere","text":"hamming_sphere(Œ£‚Åø::AbstractArray, w::Vector, e::Int) -> Vector{Vector}\n\nGet the codewords of radius e of a sohere centered at word w.  That is, all words whose distance from w is exactly equal to to the radius.\n\nParameters:\n\nŒ£‚Åø::AbstractArray: An array of words in the code.\nw::Vector: A word.\ne::Int: The radius of the ball.\n\nReturns:\n\nAbstractArray: The list of words in Œ£‚Åø whose distance from w is exactly equal to e.  Returns an array of array of symbols.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.has_identity-Tuple{Array{T,2} where T}","page":"Index","title":"Main.CodingTheory.has_identity","text":"has_identity(M::Matrix) -> Bool\nhas_identity(M::Matrix, n::Integer) -> Bool\n\nChecks if a matrix has an identity in it.  If given a number n, the function will specifically check if it has an identity matrix of size n in M.\n\nSee CodingTheory._has_identity for more information.\n\n\n\nExamples\n\njulia> A = [1 0 0 2 3 0; 0 1 0 1 2 2; 0 0 1 4 3 0]\n3√ó6 Array{Int64,2}:\n 1  0  0  2  3  0\n 0  1  0  1  2  2\n 0  0  1  4  3  0\n\njulia> B = [1 0 1 2 3 0; 0 1 0 1 2 2; 0 0 1 4 3 0]\n3√ó6 Array{Int64,2}:\n 1  0  1  2  3  0\n 0  1  0  1  2  2\n 0  0  1  4  3  0\n\njulia> C = [-96 -66 20 1 0 0; -65 59 -82 0 1 0; -16 87 -113 0 0 1]\n3√ó6 Array{Int64,2}:\n-96  -66    20  1  0  0\n-65   59   -82  0  1  0\n-16   87  -113  0  0  1\n\njulia> D = [78 -99 125 -123 -111 -71 17; -115 78 40 -88 81 -40 78; -99 126 -54 1 0 0 24; -55 88 42 0 1 0 -8; 119 55 2 0 0 1 -92; -40 -21 -89 -79 59 -44 9]\n6√ó7 Array{Int64,2}:\n   78  -99  125  -123  -111  -71   17\n -115   78   40   -88    81  -40   78\n  -99  126  -54     1     0    0   24\n  -55   88   42     0     1    0   -8\n  119   55    2     0     0    1  -92\n  -40  -21  -89   -79    59  -44    9\n\njulia> has_identity(A)\ntrue\n\njulia> has_identity(B)\ntrue\n\njulia> has_identity(B, 3) # no identity matrix of size 3 exists\nfalse\n\njulia> has_identity(C)\ntrue\n\njulia> has_identity(D)\ntrue\n\njulia> has_identity(D, 4)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.has_identity_on_left-Tuple{Array{T,2} where T}","page":"Index","title":"Main.CodingTheory.has_identity_on_left","text":"has_identity_on_left(M::Matrix) -> Bool\n\nChecks if the left-hand side of a matrix contains an identity matrix.\n\n\n\nExamples\n\njulia> A = [1 0 0 2 3 0; 0 1 0 1 2 2; 0 0 1 4 3 0]\n3√ó6 Array{Int64,2}:\n 1  0  0  2  3  0\n 0  1  0  1  2  2\n 0  0  1  4  3  0\n\njulia> B = [-96 -66 20 1 0 0; -65 59 -82 0 1 0; -16 87 -113 0 0 1]\n3√ó6 Array{Int64,2}:\n -96  -66    20  1  0  0\n -65   59   -82  0  1  0\n -16   87  -113  0  0  1\n\njulia> has_identity_on_left(A)\ntrue\n\njulia> has_identity_on_left(B)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.isgolayperfect-Union{Tuple{T}, NTuple{4,T}} where T<:Int64","page":"Index","title":"Main.CodingTheory.isgolayperfect","text":"isgolayperfect(n::Int, k::Int, d::Int, q::Int) -> Bool\n\nGolay found two perfect codes.  isgolayperfect checks if a code of block length n, distance d, alphabet size q, and dimension k, is a perfect code as described by Golay.\n\nParameters:\n\nn::Int: The block length of words in the code (e.g., word \"abc\" has block length 3).\nk::Int: The dimension of the code.\nd::Int: The distance of the code (i.e., the minimum distance between codewords in the code).\nq::Int: An Int that is a prime power.  The modulus of the finite field.\n\nReturns:\n\nBool: true or false.\n\n\n\nExamples\n\njulia> isgolayperfect(11, 6, 5, 3) # this is one of golay's perfect codes\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.ishammingperfect-Tuple{Int64,Int64}","page":"Index","title":"Main.CodingTheory.ishammingperfect","text":"ishammingbound(r::Int, q::Int) -> Bool\n\nChecks if the code is a perfect code that is of the form of a generalised Hamming code.\n\nParameters:\n\nr::Int: number of rows of a parity check matrix.\nq::Int: The size of the alphabet of the code.\n\nReturns:\n\nBool: true or false\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.ishammingperfect-Union{Tuple{T}, NTuple{4,T}} where T<:Int64","page":"Index","title":"Main.CodingTheory.ishammingperfect","text":"ishammingperfect(n::Int, k::Int, d::Int, q::Int) -> Bool\nishammingperfect(q::Int, n::Int, d::Int) -> Bool\n\nChecks if the code is a perfect code that is of the form of a generalised Hamming code.\n\nParameters:\n\nq:::Int: The size of the alphabet of the code.\nn::Int: The length of the words in the code (block length).\nd::Int: The distance of the code.\nk::Int: The dimension of the code.\n\nReturns:\n\nBool: true or false\n\n\n\nExamples\n\njulia> isgolayperfect(11, 6, 5, 3) # this is one of golay's perfect codes\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.isincode-Tuple{Array{T,1} where T,AbstractArray{Int64,N} where N,Int64}","page":"Index","title":"Main.CodingTheory.isincode","text":"isincode(vÃ≤::Vector, H·µÄ::AbstractArray{Int}, n::Int) -> Bool\n\nIf the syndrome of a code is the zero vector, then the word used to calculate the syndrome is in the code.\n\nParameters:\n\nvÃ≤::Vector: A word.\nH·µÄ::AbstractArray{Int}: The transpose of a parity check matrix.\n\nReturns:\n\nBool: If the word is in the code or not (true or false).\n\n\n\nExamples\n\njulia> isincode([0, 2, 1, 2, 0, 1, 0], transpose(parity_check([1 0 0 0 2 2 2; 0 1 0 0 2 0 1; 0 0 1 0 1 0 2; 0 0 0 1 2 2 1], 3)), 3) # tests if the syndrome is equal to the zero vector, and is thus in the code\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.isirreducible-Tuple{Polynomials.Polynomial,Int64}","page":"Index","title":"Main.CodingTheory.isirreducible","text":"isirreducible(f::AbstractPolynomial, modulo::Int) -> Bool\n\nChecks if a polynomial is irreducible.\n\nParameters:\n\nf::Polynomial: The polynomial you need to check.\nmodulo::Int: The modulus under which you are working.\n\nReturns:\n\nBool: Whether or not the polynomial is irreducible (true or false).\n\n\n\nExamples\n\njulia> isirreducible(Polynomial([1, 1, 0, 0, 1]), 2) # is 1 + x + x^4 mod 2 irreducible?\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.islinear-Tuple{Array{T,1} where T,Int64}","page":"Index","title":"Main.CodingTheory.islinear","text":"islinear(C::Vector, modulo::Int; verbose::Bool = false) -> Bool\n\nDetermines whether a code C is a linear code (i.e., if it is closed under addition, scalar multiplication, and has the zero vector in it).\n\nParameters:\n\nC::Vector: A code, typically consisting of multiple vectors or strings.\nmodulo::Int: The modulus of the field under which you are working.\nverbose::Bool (kwarg): print the point at which C fails, if it does.\n\nReturns:\n\nBool: Whether or not the code C is linear (true or false).\n\n\n\nExamples\n\n\njulia> islinear([[0,0,0],[1,1,1],[1,0,1],[1,1,0]], 2) # checks whether a vector of vectors is linear/a subspace (modulo 2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.isperfect-Union{Tuple{T}, NTuple{4,T}} where T<:Int64","page":"Index","title":"Main.CodingTheory.isperfect","text":"isperfect(n::Int, k::Int, d::Int, q::Int) -> Bool\n\nChecks if a code is perfect.  That is, checks if the number of words in the code is exactly the \"Hamming bound\", or the \"Sphere Packing Bound\".\n\nParameters:\n\nq:::Int: The size of the alphabet of the code.\nn::Int: The length of the words in the code (block length).\nd::Int: The distance of the code.\nk::Int: The dimension of the code.\n\nReturns:\n\nBool: true or false\n\n\n\nExamples\n\njulia> isperfect(11, 6, 5, 3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.levenshtein-Tuple{AbstractString,AbstractString}","page":"Index","title":"Main.CodingTheory.levenshtein","text":"levenshtein(source::AbstractString, target::AbstractString) -> Integer\nlevenshtein(source::AbstractString, target::AbstractString, cost::Real) -> Integer\nlevenshtein(\n    source::AbstractString,\n    target::AbstractString,\n    deletion_cost::R,\n    insertion_cost::S,\n    substitution_cost::T) -> Integer\nlevenshtein!(\n    source::AbstractString,\n    target::AbstractString,\n    deletion_cost::R,\n    insertion_cost::S,\n    substitution_cost::T,\n    costs::Matrix = Array{promote_type(R, S, T)}(undef, 2, length(target) + 1)\n) -> Integer\n\nComputes the Levenshtein distance.\n\nThese methods are adapted from Levenshtein.jl, by Roger Tu.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.list_polys-Tuple{Int64,Int64}","page":"Index","title":"Main.CodingTheory.list_polys","text":"list_polys(n::Int, m::Int) -> Array\n\nLists all polynomials of degree less than to n under modulo m.\n\nParameters:\n\nn::Int: Highest degree of polynomial.\nm::Int: The modulus of the field.\n\nReturns:\n\nArray: An array of polynomials of degree less than n, under modulo m.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.list_span-Tuple","page":"Index","title":"Main.CodingTheory.list_span","text":"list_span(uÃ≤::Vector, vÃ≤::Vector,... modulo::Int) -> Array\n\nGiven any number of vectors uÃ≤, vÃ≤,... , prints all linear combinations of those vectors, modulo modulo.\n\nParameters:\n\nuÃ≤::Vector: One vector.\nvÃ≤::Vector: Another vector.\n...: Other vectors.\nmodulo::Int: The modulus of the field.\n\nReturns:\n\nArray: All vectors in the span of uÃ≤ and vÃ≤, under modulo.\n\n\n\nExamples\n\njulia> list_span([2, 1, 1], [1, 1, 1], 3) # list the span of two vectors modulo 3\n9-element Array{Array{T,1} where T,1}:\n [0, 0, 0]\n [1, 1, 1]\n [2, 2, 2]\n [2, 1, 1]\n [0, 2, 2]\n [1, 0, 0]\n [1, 2, 2]\n [2, 0, 0]\n [0, 1, 1]\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.multiplication_table-Tuple{Int64,Int64}","page":"Index","title":"Main.CodingTheory.multiplication_table","text":"multiplication_table(degree::Int, modulo::Int) -> Matrix\n\nReturns a table (matrix) of the multiplication of all combinations of polynomials for degree less than degree, under modulo modulo.\n\nParameters:\n\ndegree::Int: Highest degree of polynomial.\nmodulo::Int: The modulus of the field.\n\nReturns:\n\nMatrix: A multiplication table of all polynomials with degree less than n, under modulus.\n\n\n\nExamples\n\njulia> julia> multiplication_table(2, 3) # multiplication table of all polynomials of degree less than 3 modulo 2\n9√ó9 Array{Polynomial,2}:\n Polynomial(0)  Polynomial(0)        Polynomial(0)        ‚Ä¶  Polynomial(0)                Polynomial(0)\n Polynomial(0)  Polynomial(1)        Polynomial(2)           Polynomial(1 + 2*x)          Polynomial(2 + 2*x)\n Polynomial(0)  Polynomial(2)        Polynomial(1)           Polynomial(2 + x)            Polynomial(1 + x)\n Polynomial(0)  Polynomial(x)        Polynomial(2*x)         Polynomial(x + 2*x^2)        Polynomial(2*x + 2*x^2)\n Polynomial(0)  Polynomial(1 + x)    Polynomial(2 + 2*x)     Polynomial(1 + 2*x^2)        Polynomial(2 + x + 2*x^2)\n Polynomial(0)  Polynomial(2 + x)    Polynomial(1 + 2*x)  ‚Ä¶  Polynomial(2 + 2*x + 2*x^2)  Polynomial(1 + 2*x^2)\n Polynomial(0)  Polynomial(2*x)      Polynomial(x)           Polynomial(2*x + x^2)        Polynomial(x + x^2)\n Polynomial(0)  Polynomial(1 + 2*x)  Polynomial(2 + x)       Polynomial(1 + x + x^2)      Polynomial(2 + x^2)\n Polynomial(0)  Polynomial(2 + 2*x)  Polynomial(1 + x)       Polynomial(2 + x^2)          Polynomial(1 + 2*x + x^2)\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.mutate_codeword-Union{Tuple{N}, Tuple{T}, Tuple{Union{AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}},Int64,T}} where N where T","page":"Index","title":"Main.CodingTheory.mutate_codeword","text":"mutate_codeword(w::NonStaticAbstractWord{N, T}, n::Int, i::Int, a::T) where {T, N} -> MVector{N, T}\nmutate_codeword(w::Word{N, T}, n::Int, i::Int, a::T) where {T, N} -> MVector{N, T}\n\nMutates the word w, which is an MVector of length N, changing its i·µó ∞ index to a.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.normal_form!-Tuple{AbstractArray{Int64,N} where N,Int64}","page":"Index","title":"Main.CodingTheory.normal_form!","text":"normal_form!(M::AbstractArray{Int}, n::Int) -> Matrix{Int}\n\nConvert a matrix M into normal form under modulo n via Gauss-Jordan elimination.  This directly changes the matrix M.  Use normal_form for a non-mutating version of this function.\n\nParameters:\n\nM::AbstractArray{Int}: A matrix of Ints.\nn::Int: The modulus of the finite field.\n\nReturns:\n\nMatrix{Int}: A matrix in normal form from Gauss-Jordan elimination.\n\n\n\nExamples\n\n\njulia> normal_form!([1 2 0 1 2 1 2; 2 2 2 0 1 1 1; 1 0 1 1 2 1 2; 0 1 0 1 1 2 2], 3) # computes rref colswap = false\n4√ó7 Array{Int64,2}:\n1  0  0  0  2  2  2\n0  1  0  0  2  0  1\n0  0  1  0  1  0  2\n0  0  0  1  2  2  1\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.normal_form-Tuple{AbstractArray{Int64,N} where N,Int64}","page":"Index","title":"Main.CodingTheory.normal_form","text":"normal_form(M::AbstractArray{Int}, n::Int) -> Matrix{Int}\n\nConvert a matrix M into normal form under modulo n via Gauss-Jordan elimination.\n\nParameters:\n\nM::AbstractArray{Int}: A matrix of Ints.\nn::Int: The modulus of the finite field.\n\nReturns:\n\nMatrix{Int}: A matrix in normal form from Gauss-Jordan elimination.\n\n\n\nExamples\n\n\njulia> normal_form([1 2 0 1 2 1 2; 2 2 2 0 1 1 1; 1 0 1 1 2 1 2; 0 1 0 1 1 2 2], 3) # computes rref colswap = false\n4√ó7 Array{Int64,2}:\n1  0  0  0  2  2  2\n0  1  0  0  2  0  1\n0  0  1  0  1  0  2\n0  0  0  1  2  2  1\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.parity_check-Tuple{AbstractArray{Int64,N} where N,Int64}","page":"Index","title":"Main.CodingTheory.parity_check","text":"parity_check(M::AbstractArray{Int}, n::Int) -> Matrix{Int}\n\nConstructs a parity check matrix.  This is calculated from taking the non-identity part of a matrix in normal form (or equivalent &mdash; see generator), transposing it, multiplying it by negative one, and appending to it an appropriate sized identity matrix.\n\nParameters:\n\nM::AbstractArray{Int}: A matrix of Ints.\nn::Int: The modulus of the finite field.\n\nReturns:\n\nMatrix{Int}: A parity check matrix.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.push_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1},T,Int64}} where T<:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)","page":"Index","title":"Main.CodingTheory.push_if_allowed!","text":"push_if_allowed!(C::AbstractArray{T}, C‚Ä≤::AbstractArray{T}, w::T, d::Int)\n\nTakes in two arrays, A and B.  If w is allowed in C given distance d, push to C‚Ä≤.  If we are successful in doing this, return true.  Otherwise, return false.  This is a mutating function.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.push_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,T,Int64}} where T<:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)","page":"Index","title":"Main.CodingTheory.push_if_allowed!","text":"push_if_allowed!(C::AbstractArray{T}, w::T, d::Int)\n\nTakes in an array and a word.  As long as the word does not mean that the distance is smaller than d, we add w to the array.  If we are successful in doing this, return true.  Otherwise, return false.  This is a mutating function.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.rate-Union{Tuple{T}, Tuple{T,T,T}} where T<:Integer","page":"Index","title":"Main.CodingTheory.rate","text":"rate(q::Integer, M::Integer, n::Integer) -> Real\n\nCalculate the rate of a code.  That is, how efficient the code is.\n\nParameters:\n\nq::Integer: the number of symbols in the code.\nM::Integer: the size/number of elements in the code.\nn::Integer: The word length.\n\nReturns:\n\nReal: Rate of the code.\n\n\n\nExamples\n\njulia> rate(3, 5, 4) # the rate of the code which has 3 symbols, 5 words in the code, and word length of 4 (e.g., Œ£ = {A, B, C}, C = {ABBA,CABA,BBBB,CAAB,ACBB})\n0.3662433801794817\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.replace_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T,1},Int64,Pair}} where T<:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)","page":"Index","title":"Main.CodingTheory.replace_if_allowed!","text":"replace_if_allowed!(C::AbstractArray, d::Int, w, w‚Ä≤) -> Bool\n\nTakes in an array and a word.  As long as the word does not mean that the distance is smaller than d, we replace a with b in the array.  Replaces and returns true if allowed; otherwise returns false.  This is a mutating function.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.rref!-Tuple{Array{Int64,2},Int64}","page":"Index","title":"Main.CodingTheory.rref!","text":"rref!(A::Matrix{Int}, n::Int; colswap::Bool=false, verbose::Bool=false, vverbose::Bool=false) -> Matrix{Int}\n\nPerforms Gauss-Jordan Elimination on a matrix A.  This directly changes the matrix A.  Use rref for a non-mutating version of this function.\n\nParameters:\n\nA::Matrix{Int}: A matrix of Ints you wish to perform Gauss-Jordan elimiation on.\nn::Int: The modulus of the finite field you are working under.\ncolswap::Bool (kwarg): Whether or not you allow for column swapping.\nverbose::Bool (kwarg): Print the row operations.\nvverbose::Bool (kwarg): Print the intermediate matrices of the algorithm.\n\nReturns:\n\nMatrix{Int}: a matrix in row echelon form.\n\n\n\nExamples\n\njulia> rref!([1 1 0 2 3 1; 2 0 1 3 4 1; 1 2 2 1 4 3], 5, colswap=true) # gauss-jordan elimitation modulo 5 with column swapping\n3√ó6 Array{Int64,2}:\n 1  0  0  3  2  2\n 0  1  0  2  1  1\n 0  0  1  0  0  4\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.rref-Tuple{Array{Int64,2},Int64}","page":"Index","title":"Main.CodingTheory.rref","text":"rref(A::Matrix{Int}, n::Int; colswap::Bool=false, verbose::Bool=false, vverbose::Bool=false) -> Matrix{Int}\n\nPerforms Gauss-Jordan Elimination on a matrix A.\n\nParameters:\n\nA::Matrix{Int}: A matrix of Ints you wish to perform Gauss-Jordan elimiation on.\nn::Int: The modulus of the finite field you are working under.\ncolswap::Bool (kwarg): Whether or not you allow for column swapping.\nverbose::Bool (kwarg): Print the row operations.\nvverbose::Bool (kwarg): Print the intermediate matrices of the algorithm.\n\nReturns:\n\nMatrix{Int}: a matrix in row echelon form.\n\n\n\nExamples\n\njulia> rref([1 1 0 2 3 1; 2 0 1 3 4 1; 1 2 2 1 4 3], 5, colswap=true) # gauss-jordan elimitation modulo 5 with column swapping\n3√ó6 Array{Int64,2}:\n 1  0  0  3  2  2\n 0  1  0  2  1  1\n 0  0  1  0  0  4\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.sizeof_all_words-Tuple{Int64,Int64}","page":"Index","title":"Main.CodingTheory.sizeof_all_words","text":"sizeof_all_words(q::Number, n::Number) -> Number\n\nCalculates the number of gigabytes required to store all unique words of length n from an alphabet of size q.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.sizeof_perfect_code-Tuple{Int64,Int64,Int64}","page":"Index","title":"Main.CodingTheory.sizeof_perfect_code","text":"sizeof_perfect_code(q::Number, n::Number, d::Number) -> Number\n\nCalculates the number of gigabytes required to store a perfect code of parameters q, n, and d.\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.sphere_covering_bound-Union{Tuple{T}, Tuple{T,T,T}} where T<:Integer","page":"Index","title":"Main.CodingTheory.sphere_covering_bound","text":"sphere_covering_bound(q::Integer, n::Integer, d::Integer) -> Integer\n\nComputes the sphere covering bound of a n d_q-code.\n\nParameters:\n\nq::Integer: the number of symbols in the code.\nn::Integer: the word length.\nd::Integer: the distance of the code.\n\nReturns:\n\nInteger: the sphere covering bound.\n\n\n\nExamples\n\njulia> sphere_covering_bound(5,7,3)\n215\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.sphere_packing_bound-Union{Tuple{T}, Tuple{T,T,T}} where T<:Integer","page":"Index","title":"Main.CodingTheory.sphere_packing_bound","text":"sphere_packing_bound(q::Integer, n::Integer, d::Integer) -> Integer\nsphere_packing_bound(q::Integer, n::Integer, d::Integer, ::Rounding) -> Real\n\nComputes the sphere packing bound of a n d_q-code.  The sphere packing bound is also known as the hamming bound.  You can use hamming_bound to compute the same thing.\n\nParameters:\n\nq::Integer: the number of symbols in the code.\nn::Integer: the word length.\nd::Integer: the distance of the code.\n::Rounding: use the argument no_round in this position to preserve the rounding of the code &mdash; which usually by default rounds down.\n\nReturns:\n\nInteger: the sphere packing bound.\n\n\n\nExamples\n\njulia> sphere_packing_bound(5,7,3)\n2693\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.syndrome-Tuple{Array{T,1} where T,AbstractArray{Int64,N} where N,Int64}","page":"Index","title":"Main.CodingTheory.syndrome","text":"syndrome(vÃ≤::Vector, H·µÄ::AbstractArray{Int}, n::Int) -> Matrix{Int}\n\nCalculates the syndrome of a given word vÃ≤ and a parity check matrix, transposed (H·µÄ), under modulo n.\n\nParameters:\n\nvÃ≤::Vector: A word in the code.\nH·µÄ::AbstractArray{Int}: The transpose of a parity check matrix.\n\nReturns:\n\nVector: The syndrome of a word in the code.\n\n\n\nExamples\n\njulia> syndrome([0, 2, 1, 2, 0, 1, 0], [1 1 1; 1 0 2; 2 0 1; 1 1 2; 1 0 0; 0 1 0; 0 0 1], 3)\n1√ó3 Array{Int64,2}:\n0  0  0\n\njulia> syndrome([0, 2, 1, 2, 0, 1, 0], transpose(parity_check([1 0 0 0 2 2 2; 0 1 0 0 2 0 1; 0 0 1 0 1 0 2; 0 0 0 1 2 2 1], 3)), 3)\n1√ó3 Array{Int64,2}:\n 0  0  0\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.t_error_correcting-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T<:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}","page":"Index","title":"Main.CodingTheory.t_error_correcting","text":"t_error_correcting(C::AbstractArray{T}, t::Int) -> Bool\n\nCheck if a given code C can correct t many errors.\n\nParameters:\n\nC::AbstractArray: An array of words in the code.\nt::Int: The number of errors you want to check that the code can correct.\n\nReturns:\n\nBool: Yes, C can correct t errors, or no it cannot (true of false).\n\n\n\n\n\n","category":"method"},{"location":"#Main.CodingTheory.t_error_detecting-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T<:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}","page":"Index","title":"Main.CodingTheory.t_error_detecting","text":"t_error_detecting(C::AbstractArray{T}, t::Int) -> Bool\n\nCheck if a given code C can detect t many errors.\n\nParameters:\n\nC::AbstractArray: An array of words in the code.\nt::Int: The number of errors you want to check that the code can detect.\n\nReturns:\n\nBool: Yes, C can detect t errors, or no it cannot (true of false).\n\n\n\nExamples\n\njulia> t_error_detecting([[1, 0, 1], [0, 1, 1], [1, 0, 0]], 3)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"","page":"Index","title":"Index","text":"","category":"page"}]
}
