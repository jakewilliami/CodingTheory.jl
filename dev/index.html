<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index ¬∑ CodingTheory Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CodingTheory Documentation</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Index</a><ul class="internal"><li><a class="tocitem" href="#Adding-CodingTheory.jl"><span>Adding CodingTheory.jl</span></a></li><li><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jakewilliami/CodingTheory.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="CodingTheory.jl-Documentation"><a class="docs-heading-anchor" href="#CodingTheory.jl-Documentation">CodingTheory.jl Documentation</a><a id="CodingTheory.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#CodingTheory.jl-Documentation" title="Permalink"></a></h1><ul><li><a href="#CodingTheory.jl-Documentation">CodingTheory.jl Documentation</a></li><ul><li><a href="#Adding-CodingTheory.jl">Adding CodingTheory.jl</a></li><li><a href="#Documentation">Documentation</a></li><li><a href="#Index">Index</a></li></ul></ul><h2 id="Adding-CodingTheory.jl"><a class="docs-heading-anchor" href="#Adding-CodingTheory.jl">Adding CodingTheory.jl</a><a id="Adding-CodingTheory.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-CodingTheory.jl" title="Permalink"></a></h2><pre><code class="language-julia-repl">julia&gt; using Pkg

julia&gt; Pkg.add(&quot;CodingTheory&quot;)
   Updating registry at `~/.julia/registries/General`
  Resolving package versions...
  Installed CodingTheory ‚îÄ v0.2.2
Updating `~/work/CodingTheory.jl/CodingTheory.jl/docs/Project.toml`
  [89c41d41] ~ CodingTheory v0.2.2 `~/work/CodingTheory.jl/CodingTheory.jl` ‚áí v0.2.2
Updating `~/work/CodingTheory.jl/CodingTheory.jl/docs/Manifest.toml`
  [89c41d41] ~ CodingTheory v0.2.2 `~/work/CodingTheory.jl/CodingTheory.jl` ‚áí v0.2.2</code></pre><h2 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.AbstractWord" href="#Main.CodingTheory.AbstractWord"><code>Main.CodingTheory.AbstractWord</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractWord{N} = Union{NonStaticAbstractWord{N, T}, MVector{T}} where {T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/abstract_types.jl#L61-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.NonStaticAbstractWord" href="#Main.CodingTheory.NonStaticAbstractWord"><code>Main.CodingTheory.NonStaticAbstractWord</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NonStaticAbstractWord{N, T} = Union{NTuple{N, T}, AbstractVector{T}, AbstractString} where {N, T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/abstract_types.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.AbstractCode" href="#Main.CodingTheory.AbstractCode"><code>Main.CodingTheory.AbstractCode</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractCode end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/abstract_types.jl#L14-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.Alphabet" href="#Main.CodingTheory.Alphabet"><code>Main.CodingTheory.Alphabet</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Alphabet &lt;: AbstractCode</code></pre><p>Has the parameter Œ£, which is the alphabet; a collection of strings, characters, symbols, or Ints.</p><hr/><pre><code class="language-julia">Alphabet(Œ£::AbstractArray)</code></pre><p>A constructor method for the struct Alphabet.  Takes an array of letters in the alphabet, and attempts to parse them as 64-bit Ints.</p><hr/><pre><code class="language-julia">Alphabet{N}(Œ£::AbstractArray)
Alphabet{N}(Œ£::AbstractString)</code></pre><p>A constructor method for the struct Alphabet.  Takes in a symbols and splits it into constituent characters.  Those symbols are the letters in the alphabet.  <code>N</code> is the number of letters in the alphabet</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/abstract_types.jl#L84-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.CodeUniverse" href="#Main.CodingTheory.CodeUniverse"><code>Main.CodingTheory.CodeUniverse</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CodeUniverse &lt;: AbstractCode</code></pre><p>Defines a structure for the messages in the code.  Parameters are the abstract array of messages <code>ùí∞</code>, and the length of the messages <code>n</code>.</p><pre><code class="language-julia">CodeUniverse(ùí∞::AbstractArray, Œ£::Alphabet)</code></pre><p>An inner constructor function on the structure <code>CodeUniverse</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/abstract_types.jl#L233-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.CodeUniverseIterator" href="#Main.CodingTheory.CodeUniverseIterator"><code>Main.CodingTheory.CodeUniverseIterator</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CodeUniverseIterator &lt;: AbstractCode</code></pre><p>A structure used to iterate through a code universe, with specified universe parameters.  E.g.,</p><pre><code class="language-julia">for c in CodeUniverseIterator([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 3)
    println(c)
end</code></pre><p>Fields:</p><ul><li><code>ùí∞::UniverseParameters</code></li></ul><p>Methods:</p><pre><code class="language-julia">CodeUniverseIterator(ùí∞::UniverseParameters)
CodeUniverseIterator(Œ£::Union{Alphabet, AbstractArray}, q::Int, n::Int)
CodeUniverseIterator(Œ£::Union{Alphabet, AbstractArray}, n::Int)
CodeUniverseIterator(q::Int, n::Int)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/abstract_types.jl#L192-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.Codewords" href="#Main.CodingTheory.Codewords"><code>Main.CodingTheory.Codewords</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Codewords{N} &lt;: AbstractCode</code></pre><p>Simply a wrapper type for a vector of abstract words of length <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/abstract_types.jl#L73-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.FiniteField" href="#Main.CodingTheory.FiniteField"><code>Main.CodingTheory.FiniteField</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type FiniteField end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/abstract_types.jl#L7-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.FinitePolynomial" href="#Main.CodingTheory.FinitePolynomial"><code>Main.CodingTheory.FinitePolynomial</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct FinitePolynomial &lt;: FiniteField</code></pre><p>Has parameters <code>p</code>, which is an abstract polynomial, and <code>n</code> which is the modulus of the field under which the molynomial is defined.</p><hr/><pre><code class="language-julia">FinitePolynomial(p::AbstractPolynomial, n::Int)</code></pre><p>A constructor method for <code>FinitePolynomial</code>.  Takes in a polynomial <code>p</code> and a number <code>n</code>, and constructs a polynomial under modulo n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L7-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.Rounding" href="#Main.CodingTheory.Rounding"><code>Main.CodingTheory.Rounding</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Rounding end</code></pre><p>An abstract structure used as a parameter in a non-rounding method of <code>hamming_bound</code>.  Use <code>no_round</code> for this; a predefiend variable of the structure <code>Rounding</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/abstract_types.jl#L260-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.UniverseParameters" href="#Main.CodingTheory.UniverseParameters"><code>Main.CodingTheory.UniverseParameters</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct UniverseParameters &lt;: AbstractCode</code></pre><p>Defines a structure for the messages in the code.  Parameters are the alphabet <code>Œ£</code>, size of alphabet <code>q</code>, and block length <code>n</code></p><pre><code class="language-julia">UniverseParameters(Œ£::Alphabet, n::Int)
UniverseParameters(Œ£::AbstractArray, n::Int)
UniverseParameters(Œ£::Alphabet, q::Int, n::Int)
UniverseParameters(Œ£::AbstractArray, q::Int, n::Int)
UniverseParameters(q::Int, n::Int)</code></pre><p>An inner constructor function on the structure <code>UniverseParameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/abstract_types.jl#L144-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.Word" href="#Main.CodingTheory.Word"><code>Main.CodingTheory.Word</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct Word{N, T}
Word(w::NTuple{N, T})
Word(w::AbstractVector{T})
Word(w::AbstractString)
Word(i::T...)</code></pre><p>A Word is an <code>StaticArrays.MVector</code> which is efficient (like tuple) yet mutable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/abstract_types.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Polynomials.Polynomial-Union{Tuple{T}, Tuple{N}, Tuple{Union{Array{T,1}, Tuple{Vararg{T,N}}},Int64}} where T where N" href="#Polynomials.Polynomial-Union{Tuple{T}, Tuple{N}, Tuple{Union{Array{T,1}, Tuple{Vararg{T,N}}},Int64}} where T where N"><code>Polynomials.Polynomial</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Polynomial(A::Union{NTuple{N, T}, Vector{T}}, n::Int) -&gt; Polynomial</code></pre><p>Constructs a polynomial under modulo <code>n</code>.</p><p>Parameters:</p><ul><li><code>A::Union{Tuple, AbstractArray}</code>: The polynomial coefficients.</li><li><code>n::Int</code>: The modulus of the field.</li></ul><p>Returns</p><ul><li><code>Polynomial</code>: A polynomial modulo n.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L48-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.gensym-Tuple{Int64}" href="#Base.gensym-Tuple{Int64}"><code>Base.gensym</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gensym(q::Int) -&gt; Vector{Symbol}</code></pre><p>Generates a vector of unique symbols of length q.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/abstract_types.jl#L126-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.mod-Tuple{Polynomials.Polynomial,Int64}" href="#Base.mod-Tuple{Polynomials.Polynomial,Int64}"><code>Base.mod</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mod(p::Polynomial, n::Int) -&gt; Polynomial</code></pre><p>Uses the <code>FinitePolynomial</code> constructor to return a polynomial <code>p</code> under modulus <code>n</code>.</p><p>Parameters:</p><ul><li><code>p::Polynomial</code>: The input polynomial.</li><li><code>n::Int</code>: The modulus of the field.</li></ul><p>Returns</p><ul><li>Polynomial: A polynomial modulo n.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L32-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{UniverseParameters,AbstractArray}" href="#Base.rand-Tuple{UniverseParameters,AbstractArray}"><code>Base.rand</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rand(ùí∞::UniverseParameters, C::AbstractArray) -&gt; Tuple</code></pre><p>Given universe parameters ùí∞ and a code C, return a tuple including</p><ul><li>A random word in C;</li><li>A random letter in the alphabet; and</li><li>A random index in the block length.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/abstract_types.jl#L180-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory._has_identity-Union{Tuple{T}, Tuple{Array{T,2} where T,Union{AbstractRange{T}, Base.OneTo{T}, T}}} where T&lt;:Integer" href="#Main.CodingTheory._has_identity-Union{Tuple{T}, Tuple{Array{T,2} where T,Union{AbstractRange{T}, Base.OneTo{T}, T}}} where T&lt;:Integer"><code>Main.CodingTheory._has_identity</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_has_identity(M::Matrix, n::Union{T, Base.OneTo{T}, AbstractRange{T}}) where {T &lt;: Integer}</code></pre><p>Inner function on <code>has_identity</code> function.  Will return a tuple of:</p><ul><li>Whether or not the matrix has an identity;</li><li>Where that identity matrix starts; and</li><li>How big the identity matrix is.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L151-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.allequal-Union{Tuple{Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}, Tuple{T}} where T" href="#Main.CodingTheory.allequal-Union{Tuple{Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}, Tuple{T}} where T"><code>Main.CodingTheory.allequal</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">allequal(A) -&gt; Bool
allequal(a, b...) -&gt; Bool</code></pre><p>Check that all elements in a list are equal to each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L39-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.allequal_length-Union{Tuple{Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}, Tuple{T}} where T" href="#Main.CodingTheory.allequal_length-Union{Tuple{Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}, Tuple{T}} where T"><code>Main.CodingTheory.allequal_length</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">allequal_length(A) -&gt; Bool
allequal_length(a, b...) -&gt; Bool</code></pre><p>Check that all elements in a list are of equal length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L20-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.aredistinct-Union{Tuple{Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}, Tuple{T}} where T" href="#Main.CodingTheory.aredistinct-Union{Tuple{Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}, Tuple{T}} where T"><code>Main.CodingTheory.aredistinct</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">aredistinct(A) -&gt; Bool
aredistinct(a, b...) -&gt; Bool</code></pre><p>Check that all elements in a list are distinct from every other element in the list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L58-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.areequalto-Union{Tuple{T}, Tuple{Any,Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}} where T" href="#Main.CodingTheory.areequalto-Union{Tuple{T}, Tuple{Any,Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}} where T"><code>Main.CodingTheory.areequalto</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">areequalto(x::Number, A::AbstractArray) -&gt; Bool
areequalto(x::Number, a, b...) -&gt; Bool</code></pre><p>Check that all elements in a list are equal to a given x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L95-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.arelessthan-Union{Tuple{T}, Tuple{Number,Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}} where T" href="#Main.CodingTheory.arelessthan-Union{Tuple{T}, Tuple{Number,Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}} where T"><code>Main.CodingTheory.arelessthan</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">arelessthan(x::Number, A) -&gt; Bool
arelessthan(x::Number, a, b...) -&gt; Bool</code></pre><p>Check that all elements in a list are less than a given x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L78-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.code_distance!-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,T}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)" href="#Main.CodingTheory.code_distance!-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,T}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.code_distance!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">code_distance!(C::AbstractArray{T}, w::T) -&gt; Int</code></pre><p>A wrapper to get the code distance after pushing a word to the code.  <em>This directly changes the matrix M.  Use <code>code_distance</code> for a non-mutating version of this function.</em></p><p>Parameters:</p><ul><li><code>C::AbstractArray</code>: An array of words in the code.</li><li><code>w</code>: A word to be appended to C.</li></ul><p>Returns:</p><ul><li><code>Int</code>: The code distance after adding w to C.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/distance.jl#L131-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.code_distance-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)" href="#Main.CodingTheory.code_distance-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.code_distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">code_distance(C::AbstractArray) -&gt; Int</code></pre><p>Finds the distance of the code.  That is, given a code C, finds the minimum distance between any two words in the code, which are not the same. (Find the minimum hamming distance in the code for all unique letters).</p><p>Parameters:</p><ul><li><code>C::AbstractArray</code>: An array of words in the code.</li></ul><p>Return:</p><ul><li><code>Int</code>: the distance of the code.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/distance.jl#L101-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.code_distance-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,T}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)" href="#Main.CodingTheory.code_distance-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,T}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.code_distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">code_distance(C::AbstractArray{T}, w::T) -&gt; Int</code></pre><p>A wrapper to get the code distance after pushing a word to the code.</p><p>Parameters:</p><ul><li><code>C::AbstractArray</code>: An array of words in the code.</li><li><code>w</code>: A word to be appended to C.</li></ul><p>Returns:</p><ul><li><code>Int</code>: The code distance after adding w to C.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; code_distance([[0,0,0,0,0],[1,0,1,0,1],[0,1,0,1,0],[1,1,1,1,1]]) # gets the minimum distance between two vectors in an array of vectors
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/distance.jl#L150-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.construct_ham_matrix-Tuple{Int64,Int64}" href="#Main.CodingTheory.construct_ham_matrix-Tuple{Int64,Int64}"><code>Main.CodingTheory.construct_ham_matrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">construct_ham_matrix(r::Int, q::Int) -&gt; Matrix</code></pre><p>Construct a Hamming parity-check matrix.</p><p>Parameters:</p><ul><li><code>r::Int</code>: number of rows of a parity check matrix.</li><li><code>q:::Int</code>: The size of the alphabet of the code.</li></ul><p>Returns:</p><ul><li><code>Matrix</code>: The Hamming matrix, denoted as <span>$\text{Ham}(r, q)$</span></li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; construct_ham_matrix(3,2)
3√ó7 Array{Int64,2}:
 0  0  0  1  1  1  1
 0  1  1  0  0  1  1
 1  0  1  0  1  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L165-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.deepeltype-Tuple{Any}" href="#Main.CodingTheory.deepeltype-Tuple{Any}"><code>Main.CodingTheory.deepeltype</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deepeltype(a::AbstractArray) -&gt; Type</code></pre><p>Returns the type of the inner-most element in a nested array structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L122-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.deepsym-Tuple{Any}" href="#Main.CodingTheory.deepsym-Tuple{Any}"><code>Main.CodingTheory.deepsym</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">deepsym(a::AbstractArray)</code></pre><p>Convert inner-most elements into symbols</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L112-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.displaymatrix-Tuple{AbstractArray}" href="#Main.CodingTheory.displaymatrix-Tuple{AbstractArray}"><code>Main.CodingTheory.displaymatrix</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">displaymatrix(M::AbstractArray)</code></pre><p>Displays a matrix <code>M</code> in a compact form from the terminal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L7-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.ensure_symbolic!-Tuple{Any}" href="#Main.CodingTheory.ensure_symbolic!-Tuple{Any}"><code>Main.CodingTheory.ensure_symbolic!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ensure_symbolic!(Œ£) -&gt; typeof(Œ£)</code></pre><p>Ensures that the inner-most elements of a nested array structure are of the type <code>Symbol</code>.  <em>This is a mutating function.  Use its twin, non-mutating function, <code>ensure_symbolic</code>, if you need a non-mutating version of this.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L133-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.ensure_symbolic-Tuple{Any}" href="#Main.CodingTheory.ensure_symbolic-Tuple{Any}"><code>Main.CodingTheory.ensure_symbolic</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ensure_symbolic(Œ£) -&gt; typeof(Œ£)</code></pre><p>Ensures that the inner-most elements of a nested array structure are of the type <code>Symbol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L142-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.equivalent_code!-Tuple{AbstractArray{Int64,N} where N,Int64}" href="#Main.CodingTheory.equivalent_code!-Tuple{AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.equivalent_code!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">equivalent_code!(M::AbstractArray{Int}, n::Int) -&gt; Matrix{Int}</code></pre><p>Peforms Gauss-Jordan elimination on a matrix M, but allows for column swapping.  This constructs an &quot;equivalent&quot; matrix.  <em>This directly changes the matrix M.  Use <code>equivalent_code</code> for a non-mutating version of this function.</em></p><p>Parameters:</p><ul><li><code>M::AbstractArray{Int}</code>: A matrix of Ints.</li><li><code>n::Int</code>: The modulus of the finite field.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: A which represents an &quot;equivalent&quot; code to that of the matrix M.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; equivalent_code!([1 2 0 1 2 1 2; 2 2 2 0 1 1 1; 1 0 1 1 2 1 2; 0 1 0 1 1 2 2], 3) # computes rref colswap = true
4√ó7 Array{Int64,2}:
1  0  0  0  2  2  2
0  1  0  0  2  0  1
0  0  1  0  1  0  2
0  0  0  1  2  2  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L337-L364">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.equivalent_code-Tuple{AbstractArray{Int64,N} where N,Int64}" href="#Main.CodingTheory.equivalent_code-Tuple{AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.equivalent_code</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">equivalent_code(M::AbstractArray{Int}, n::Int) -&gt; Matrix{Int}</code></pre><p>Peforms Gauss-Jordan elimination on a matrix M, but allows for column swapping.</p><p>Parameters:</p><ul><li><code>M::AbstractArray{Int}</code>: A matrix of Ints.</li><li><code>n::Int</code>: The modulus of the finite field.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: A which represents an &quot;equivalent&quot; code to that of the matrix M.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; equivalent_code([1 2 0 1 2 1 2; 2 2 2 0 1 1 1; 1 0 1 1 2 1 2; 0 1 0 1 1 2 2], 3) # computes rref colswap = true
4√ó7 Array{Int64,2}:
1  0  0  0  2  2  2
0  1  0  0  2  0  1
0  0  1  0  1  0  2
0  0  0  1  2  2  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L369-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.find_error_correction_max-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T&lt;:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}" href="#Main.CodingTheory.find_error_correction_max-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T&lt;:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}"><code>Main.CodingTheory.find_error_correction_max</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_error_correction_max(C::AbstractArray{T}, modulo::Int) -&gt; Int</code></pre><p>Finds the greatest number t such that C is error t error correcting.</p><p>Parameters:</p><ul><li><code>C::AbstractArray</code>: An array of words in the code.</li><li><code>moldulo::Int</code>: The modulus of the finite field.  The upper bound of t.</li></ul><p>Returns:</p><ul><li><code>Int</code>: The maximum number t such that the code is t error correcting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/distance.jl#L252-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.find_error_detection_max-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T&lt;:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}" href="#Main.CodingTheory.find_error_detection_max-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T&lt;:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}"><code>Main.CodingTheory.find_error_detection_max</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">find_error_detection_max(C::AbstractArray{T}, modulo::Int) -&gt; Int</code></pre><p>Finds the greatest number t such that C is error t error detecting.</p><p>Parameters:</p><ul><li><code>C::AbstractArray</code>: An array of words in the code.</li><li><code>moldulo::Int</code>: The modulus of the finite field.  The upper bound of t.</li></ul><p>Returns:</p><ul><li><code>Int</code>: The maximum number t such that the code is t error detecting.</li></ul><hr/><pre><code class="language-julia">julia&gt; find_error_detection_max([[0, 0, 0, 0], [0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1]], 2)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/distance.jl#L225-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.genalphabet-Tuple{Int64}" href="#Main.CodingTheory.genalphabet-Tuple{Int64}"><code>Main.CodingTheory.genalphabet</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">genalphabet(q::Int)</code></pre><p>Generates an alphabet of q unique symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/abstract_types.jl#L135-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.generator!-Tuple{AbstractArray{Int64,N} where N,Int64}" href="#Main.CodingTheory.generator!-Tuple{AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.generator!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generator!(M::AbstractArray{Int}, n::Int; colswap::Bool = true) -&gt; Matrix{Int}</code></pre><p>Constructs a generator matrix of the code, depending on if you allow for column swapping or not.   This function uses <code>normal_form!</code> or <code>equivalent_code!</code>.  <em>This directly changes the matrix M.  Use <code>generator</code> for a non-mutating version of this function.</em></p><p>Parameters:</p><ul><li><code>M::AbstractArray{Int}</code>: A matrix of Ints.</li><li><code>n::Int</code>: The modulus of the finite field.</li><li><code>colswap::Bool</code> (kwarg): A boolean flag indicating whether or not you allow for swapping of columns when constructing the generating matrix.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: A generating matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L400-L414">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.generator-Tuple{AbstractArray{Int64,N} where N,Int64}" href="#Main.CodingTheory.generator-Tuple{AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.generator</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">generator(M::AbstractArray{Int}, n::Int; colswap::Bool = true) -&gt; Matrix{Int}</code></pre><p>Constructs a generator matrix of the code, depending on if you allow for column swapping or not.  This function uses <code>normal_form</code> or <code>equivalent_code</code>.</p><p>Parameters:</p><ul><li><code>M::AbstractArray{Int}</code>: A matrix of Ints.</li><li><code>n::Int</code>: The modulus of the finite field.</li><li><code>colswap::Bool</code> (kwarg): A boolean flag indicating whether or not you allow for swapping of columns when constructing the generating matrix.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: A generating matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L419-L433">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.get_all_words-Union{Tuple{N}, Tuple{Alphabet{N},Int64,Int64}} where N" href="#Main.CodingTheory.get_all_words-Union{Tuple{N}, Tuple{Alphabet{N},Int64,Int64}} where N"><code>Main.CodingTheory.get_all_words</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_all_words(Œ£::Alphabet{N}, q::Int, n::Int) -&gt; Codewords{M}
get_all_words(Œ£::Alphabet{N}, n::Int) -&gt; Codewords{M}
get_all_words(Œ£::AbstractArray, q::Int, n::Int) -&gt; Codewords{M}
get_all_words(Œ£::AbstractArray, n::Int) -&gt; Codewords{M}
get_all_words(q::Int, n::Int) -&gt; Codewords{M}</code></pre><p>Get the universe of <em>all</em> codewords of a given alphabet.  The alphabet will be uniquely generated if none is given.</p><p>Parameters:</p><ul><li><code>Œ£::AbstractArray</code>: The alphabet allowed.</li><li><code>q::Int</code>: The size of the alphabet.</li><li><code>n::Int</code>: The (fixed) length of the words in the code.</li><li><code>d::Int</code>: The minimum distance between words in the code.</li><li><code>ùí∞::AbstractArray</code>: The universe of all codewords of q many letters of block length n.</li></ul><p>Returns:</p><ul><li><code>Codewords{M}</code>: An array of codewords, each of length <code>M</code>.  Each codewords is a tuple, and each character in said word is a symbol.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; get_all_words(2, 2) # all words of block length 2 using 2 unique symbols
2√ó2 Array{Tuple{Symbol,Symbol},2}:
 (Symbol(&quot;##254&quot;), Symbol(&quot;##254&quot;))  (Symbol(&quot;##254&quot;), Symbol(&quot;##253&quot;))
 (Symbol(&quot;##253&quot;), Symbol(&quot;##254&quot;))  (Symbol(&quot;##253&quot;), Symbol(&quot;##253&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L428-L459">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.get_codewords-Tuple{AbstractArray,Int64}" href="#Main.CodingTheory.get_codewords-Tuple{AbstractArray,Int64}"><code>Main.CodingTheory.get_codewords</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_codewords(G::AbstractArray, m::Int) -&gt; Codewords{M}</code></pre><p>Get codewords of a code from the <em>generating matrix</em> under a finite field of modulo <code>m</code>.  Precisely, computes all linear combinations of the rows of the generating matrix.</p><p>Parameters:</p><ul><li><code>G::AbstractArray</code>: A matrix of Ints which generates the code.</li><li><code>m::Int</code>: The bounds of the finite field (i.e., the molulus you wish to work in).</li></ul><p>Returns:</p><ul><li><code>Codewords{M}</code>: An array of codewords, each of length <code>M</code>.  Each codewords is a tuple, and each character in said word is a symbol.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L693-L706">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.get_codewords-Tuple{UniverseParameters,Int64}" href="#Main.CodingTheory.get_codewords-Tuple{UniverseParameters,Int64}"><code>Main.CodingTheory.get_codewords</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_codewords(ùí∞::UniverseParameters, d::Int; m::Int=10, m_random::Int = 1000) -&gt; Codewords{M}
get_codewords(Œ£::Alphabet{N}, q::Int, n::Int, d::Int; m::Int=10, m_random::Int=1000) -&gt; Codewords{M}
get_codewords(q::Int, n::Int, d::Int; m::Int=10, m_random::Int=1000) -&gt; Codewords{M}
get_codewords(q::Int, n::Int, d::Int; m::Int=10, m_random::Int=1000) -&gt; Codewords{M}
get_codewords(Œ£::AbstractArray, q::Int, n::Int, d::Int; m::Int=10, m_random::Int=1000) -&gt; Codewords{M}
get_codewords(Œ£::AbstractArray, n::Int, d::Int; m::Int=10, m_random::Int=1000) -&gt; Codewords{M}
get_codewords(Œ£::AbstractArray, q::Int, n::Int, d::Int, ùí∞::AbstractArray; m::Int=10, m_random::Int=1000) -&gt; Codewords{M}</code></pre><p>Use function <code>get_codewords_random</code> <code>m</code> many times (with <code>get_codewords_random(..., m = m_random)</code>), and <code>get_codewords_greedy</code>.  Return the code with the greatest number of words.  The alphabet will be uniquely generated if none is given.  You can omit Œ£ and ùí∞.  You can omit q if Œ£ is given.</p><p>Parameters:</p><ul><li><code>Œ£::AbstractArray</code>: The alphabet allowed.</li><li><code>q::Int</code>: The size of the alphabet.</li><li><code>n::Int</code>: The (fixed) length of the words in the code.</li><li><code>d::Int</code>: The minimum distance between words in the code.</li><li><code>ùí∞::AbstractArray</code>: The universe of all codewords of q many letters of block length n.</li><li><code>m::Int</code> (kwarg): Try a random code m many times.</li><li><code>m_random::Int</code> (kwarg): The number of possible words <code>get_codewords_random</code> chooses from for <em>each</em> word it selects.</li></ul><p>Returns:</p><ul><li><code>Codewords{M}</code>: An array of codewords, each of length <code>M</code>.  Each codewords is a tuple, and each character in said word is a symbol.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><pre><code class="language-none">*If you are looking for a _maximal_ code, this is likely the function you need.*  Increasing `m` and `m_random` arbitrarily should ensure a maximal code‚Äî_however_, that computing power/time in not always possible, as it requires a lot of RAM to store certain codes in memeory.  Efforts are being made to make this process better by using memory-mapped filed instead of storing codewords in RAM, but this will make it much slower as well.  Help with this would be much appreciated.</code></pre><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; get_codewords([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 3, 2) # get codewords of block length 3 with distance 2.  Once again, are symbols for uniqueness
9-element Array{Tuple{Symbol,Symbol,Symbol},1}:
 (:a, :b, :a)
 (:c, :a, :b)
 (:b, :c, :c)
 (:b, :a, :a)
 (:c, :b, :c)
 (:a, :a, :c)
 (:a, :c, :b)
 (:c, :c, :a)
 (:b, :b, :b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L610-L656">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.get_codewords_greedy-Tuple{UniverseParameters,Int64}" href="#Main.CodingTheory.get_codewords_greedy-Tuple{UniverseParameters,Int64}"><code>Main.CodingTheory.get_codewords_greedy</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_codewords_greedy(ùí∞::UniverseParameters, d::Int) -&gt; Codewords{M}
get_codewords_greedy(Œ£::Alphabet{N}, q::Int, n::Int, d::Int) -&gt; Codewords{M}
get_codewords_greedy(Œ£::Alphabet{N}, n::Int, d::Int) -&gt; Codewords{M}
get_codewords_greedy(q::Int, n::Int, d::Int) -&gt; Codewords{M}
get_codewords_greedy(Œ£::AbstractArray, q::Int, n::Int, d::Int) -&gt; Codewords{M}
get_codewords_greedy(Œ£::AbstractArray, n::Int, d::Int) -&gt; Codewords{M}
get_codewords_greedy(Œ£::AbstractArray, q::Int, n::Int, d::Int, ùí∞::AbstractArray) -&gt; Codewords{M}</code></pre><p>Search through the universe of all codewords and find a code of block length n and distance d, using the alphabet Œ£.  The alphabet will be uniquely generated if none is given.  This uses a greedy algorithm, simply iterating through all words (see above) and choosing them if they fit in the code.  In some cases the greedy algorithm is the best, but in others it is very much not.</p><p>Parameters:</p><ul><li><code>ùí∞::UniverseParameters</code>: The parameters of the universe of all codewords of q many letters of block length n.</li><li><code>Œ£::AbstractArray</code>: The alphabet allowed.</li><li><code>q::Int</code>: The size of the alphabet.</li><li><code>n::Int</code>: The (fixed) length of the words in the code.</li><li><code>d::Int</code>: The minimum distance between words in the code.</li></ul><p>Returns:</p><ul><li><code>Codewords{M}</code>: An array of codewords, each of length <code>M</code>.  Each codewords is a tuple, and each character in said word is a symbol.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L469-L491">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.get_codewords_random-Tuple{UniverseParameters,Int64}" href="#Main.CodingTheory.get_codewords_random-Tuple{UniverseParameters,Int64}"><code>Main.CodingTheory.get_codewords_random</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_codewords_random(ùí∞::UniverseParameters, d::Int; m::Int = 1000) -&gt; Codewords{M}
get_codewords_random(Œ£::Alphabet{N}, q::Int, n::Int, d::Int; m::Int=1000) -&gt; Codewords{M}
get_codewords_random(Œ£::Alphabet{N}, n::Int, d::Int; m::Int=1000)	-&gt; Codewords{M}
get_codewords_random(q::Int, n::Int, d::Int; m::Int=1000) -&gt; Codewords{M}
get_codewords_random(Œ£::AbstractArray, q::Int, n::Int, d::Int; m::Int=1000) -&gt; Codewords{M}
get_codewords_random(Œ£::AbstractArray, n::Int, d::Int; m::Int=1000) -&gt; Codewords{M}
get_codewords_random(Œ£::AbstractArray, q::Int, n::Int, d::Int, ùí∞::AbstractArray; m::Int=1000) -&gt; Codewords{M}</code></pre><p>Search through the universe of all codewords at random and find a code of block length n and distance d, using the alphabet Œ£.  The alphabet will be uniquely generated if none is given.  This is a cleverer algorithm than the greedy algorithm.  Increasing the <code>m</code> keyword argument arbitrarily <em>should</em> produce a maximal code, as for each codeword it chooses, it collects a list of <code>m</code> many random words, and chooses the best one from that intermediate list.</p><p>Parameters:</p><ul><li><code>Œ£::AbstractArray</code>: The alphabet allowed.</li><li><code>q::Int</code>: The size of the alphabet.</li><li><code>n::Int</code>: The (fixed) length of the words in the code.</li><li><code>d::Int</code>: The minimum distance between words in the code.</li><li><code>ùí∞::AbstractArray</code>: The universe of all codewords of q many letters of block length n.</li></ul><p>Returns:</p><ul><li><code>Codewords{M}</code>: An array of codewords, each of length <code>M</code>.  Each codewords is a tuple, and each character in said word is a symbol.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L520-L542">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.hamming_ball-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Array{S,1},Int64}} where S where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)" href="#Main.CodingTheory.hamming_ball-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Array{S,1},Int64}} where S where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.hamming_ball</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hamming_ball(Œ£‚Åø::AbstractArray, w::Vector, e::Int) -&gt; Vector{Vector}</code></pre><p>Get the codewords of radius <span>$e$</span> of a ball centered at word <span>$w$</span>.  That is, all words whose distance from w is less than or equal to the radius.</p><p>Parameters:</p><ul><li><code>Œ£‚Åø::AbstractArray</code>: An array of words in the code.</li><li><code>w::Vector</code>: A word.</li><li><code>e::Int</code>: The radius of the ball.</li></ul><p>Returns:</p><ul><li>AbstractArray: The list of words in Œ£‚Åø whose distance from w is less than or equal to e.  Returns an array of array of symbols.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; hamming_ball([[1, 0, 1], [0, 1, 1], [1, 0, 0]], [1, 0, 0], 2) # given a list of words, a word, and a distance e (respectively), calculate all the words in the alphabet within distance e of that word.  Converts to symbols in order to keep unique lengths
2-element Array{Any,1}:
 [Symbol(&quot;1&quot;), Symbol(&quot;0&quot;), Symbol(&quot;1&quot;)]
 [Symbol(&quot;1&quot;), Symbol(&quot;0&quot;), Symbol(&quot;0&quot;)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/distance.jl#L54-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.hamming_distance-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)" href="#Main.CodingTheory.hamming_distance-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.hamming_distance</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hamming_distance(w‚ÇÅ, w‚ÇÇ) -&gt; Int</code></pre><p>The Hamming distance of two words is the number of changes that need to be made to each letter in the word for the words to be the same.  This does not work for words of unequal length.</p><p>Parameters:</p><ul><li><code>w‚ÇÅ</code>: A word.</li><li><code>w‚ÇÇ</code>: Another word.</li></ul><p>Returns:</p><ul><li><code>Int</code>: the number of changes needing to be made to one word for it to be identical to the other.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; hamming_distance(&quot;ABC&quot;, &quot;BBC&quot;) # computes the hamming distance
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/distance.jl#L8-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.hamming_sphere-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Array{S,1},Int64}} where S where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)" href="#Main.CodingTheory.hamming_sphere-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Array{S,1},Int64}} where S where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.hamming_sphere</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hamming_sphere(Œ£‚Åø::AbstractArray, w::Vector, e::Int) -&gt; Vector{Vector}</code></pre><p>Get the codewords of radius e of a sohere centered at word w.  That is, all words whose distance from w is exactly equal to to the radius.</p><p>Parameters:</p><ul><li><code>Œ£‚Åø::AbstractArray</code>: An array of words in the code.</li><li><code>w::Vector</code>: A word.</li><li><code>e::Int</code>: The radius of the ball.</li></ul><p>Returns:</p><ul><li><code>AbstractArray</code>: The list of words in Œ£‚Åø whose distance from w is exactly equal to e.  Returns an array of array of symbols.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/distance.jl#L83-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.has_identity-Tuple{Array{T,2} where T}" href="#Main.CodingTheory.has_identity-Tuple{Array{T,2} where T}"><code>Main.CodingTheory.has_identity</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_identity(M::Matrix) -&gt; Bool
has_identity(M::Matrix, n::Integer) -&gt; Bool</code></pre><p>Checks if a matrix has an identity in it.  If given a number <code>n</code>, the function will specifically check if it has an identity matrix <em>of size n</em> in <code>M</code>.</p><p>See <code>CodingTheory._has_identity</code> for more information.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; A = [1 0 0 2 3 0; 0 1 0 1 2 2; 0 0 1 4 3 0]
3√ó6 Array{Int64,2}:
 1  0  0  2  3  0
 0  1  0  1  2  2
 0  0  1  4  3  0

julia&gt; B = [1 0 1 2 3 0; 0 1 0 1 2 2; 0 0 1 4 3 0]
3√ó6 Array{Int64,2}:
 1  0  1  2  3  0
 0  1  0  1  2  2
 0  0  1  4  3  0

julia&gt; C = [-96 -66 20 1 0 0; -65 59 -82 0 1 0; -16 87 -113 0 0 1]
3√ó6 Array{Int64,2}:
-96  -66    20  1  0  0
-65   59   -82  0  1  0
-16   87  -113  0  0  1

julia&gt; D = [78 -99 125 -123 -111 -71 17; -115 78 40 -88 81 -40 78; -99 126 -54 1 0 0 24; -55 88 42 0 1 0 -8; 119 55 2 0 0 1 -92; -40 -21 -89 -79 59 -44 9]
6√ó7 Array{Int64,2}:
   78  -99  125  -123  -111  -71   17
 -115   78   40   -88    81  -40   78
  -99  126  -54     1     0    0   24
  -55   88   42     0     1    0   -8
  119   55    2     0     0    1  -92
  -40  -21  -89   -79    59  -44    9

julia&gt; has_identity(A)
true

julia&gt; has_identity(B)
true

julia&gt; has_identity(B, 3) # no identity matrix of size 3 exists
false

julia&gt; has_identity(C)
true

julia&gt; has_identity(D)
true

julia&gt; has_identity(D, 4)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L177-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.has_identity_on_left-Tuple{Array{T,2} where T}" href="#Main.CodingTheory.has_identity_on_left-Tuple{Array{T,2} where T}"><code>Main.CodingTheory.has_identity_on_left</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">has_identity_on_left(M::Matrix) -&gt; Bool</code></pre><p>Checks if the left-hand side of a matrix contains an identity matrix.</p><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; A = [1 0 0 2 3 0; 0 1 0 1 2 2; 0 0 1 4 3 0]
3√ó6 Array{Int64,2}:
 1  0  0  2  3  0
 0  1  0  1  2  2
 0  0  1  4  3  0

julia&gt; B = [-96 -66 20 1 0 0; -65 59 -82 0 1 0; -16 87 -113 0 0 1]
3√ó6 Array{Int64,2}:
 -96  -66    20  1  0  0
 -65   59   -82  0  1  0
 -16   87  -113  0  0  1

julia&gt; has_identity_on_left(A)
true

julia&gt; has_identity_on_left(B)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L243-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.isgolayperfect-Union{Tuple{T}, NTuple{4,T}} where T&lt;:Int64" href="#Main.CodingTheory.isgolayperfect-Union{Tuple{T}, NTuple{4,T}} where T&lt;:Int64"><code>Main.CodingTheory.isgolayperfect</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isgolayperfect(n::Int, k::Int, d::Int, q::Int) -&gt; Bool</code></pre><p>Golay found two perfect codes.  <code>isgolayperfect</code> checks if a code of block length n, distance d, alphabet size q, and dimension k, is a perfect code as described by Golay.</p><p>Parameters:</p><ul><li><code>n::Int</code>: The block length of words in the code (e.g., word &quot;abc&quot; has block length 3).</li><li><code>k::Int</code>: The dimension of the code.</li><li><code>d::Int</code>: The distance of the code (i.e., the minimum distance between codewords in the code).</li><li><code>q::Int</code>: An Int that is a prime power.  The modulus of the finite field.</li></ul><p>Returns:</p><ul><li><code>Bool</code>: true or false.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; isgolayperfect(11, 6, 5, 3) # this is one of golay&#39;s perfect codes
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L316-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.ishammingperfect-Tuple{Int64,Int64}" href="#Main.CodingTheory.ishammingperfect-Tuple{Int64,Int64}"><code>Main.CodingTheory.ishammingperfect</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ishammingbound(r::Int, q::Int) -&gt; Bool</code></pre><p>Checks if the code is a perfect code that is of the form of a generalised Hamming code.</p><p>Parameters:</p><ul><li><code>r::Int</code>: number of rows of a parity check matrix.</li><li><code>q::Int</code>: The size of the alphabet of the code.</li></ul><p>Returns:</p><ul><li><code>Bool</code>: true or false</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L235-L248">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.ishammingperfect-Union{Tuple{T}, NTuple{4,T}} where T&lt;:Int64" href="#Main.CodingTheory.ishammingperfect-Union{Tuple{T}, NTuple{4,T}} where T&lt;:Int64"><code>Main.CodingTheory.ishammingperfect</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ishammingperfect(n::Int, k::Int, d::Int, q::Int) -&gt; Bool
ishammingperfect(q::Int, n::Int, d::Int) -&gt; Bool</code></pre><p>Checks if the code is a perfect code that is of the form of a generalised Hamming code.</p><p>Parameters:</p><ul><li><code>q:::Int</code>: The size of the alphabet of the code.</li><li><code>n::Int</code>: The length of the words in the code (block length).</li><li><code>d::Int</code>: The distance of the code.</li><li><code>k::Int</code>: The dimension of the code.</li></ul><p>Returns:</p><ul><li><code>Bool</code>: true or false</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; isgolayperfect(11, 6, 5, 3) # this is one of golay&#39;s perfect codes
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L266-L291">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.isincode-Tuple{Array{T,1} where T,AbstractArray{Int64,N} where N,Int64}" href="#Main.CodingTheory.isincode-Tuple{Array{T,1} where T,AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.isincode</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isincode(vÃ≤::Vector, H·µÄ::AbstractArray{Int}, n::Int) -&gt; Bool</code></pre><p>If the syndrome of a code is the zero vector, then the word used to calculate the syndrome is in the code.</p><p>Parameters:</p><ul><li><code>vÃ≤::Vector</code>: A word.</li><li><code>H·µÄ::AbstractArray{Int}</code>: The transpose of a parity check matrix.</li></ul><p>Returns:</p><ul><li><code>Bool</code>: If the word is in the code or not (true or false).</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; isincode([0, 2, 1, 2, 0, 1, 0], transpose(parity_check([1 0 0 0 2 2 2; 0 1 0 0 2 0 1; 0 0 1 0 1 0 2; 0 0 0 1 2 2 1], 3)), 3) # tests if the syndrome is equal to the zero vector, and is thus in the code
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L491-L513">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.isirreducible-Tuple{Polynomials.Polynomial,Int64}" href="#Main.CodingTheory.isirreducible-Tuple{Polynomials.Polynomial,Int64}"><code>Main.CodingTheory.isirreducible</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isirreducible(f::AbstractPolynomial, modulo::Int) -&gt; Bool</code></pre><p>Checks if a polynomial is irreducible.</p><p>Parameters:</p><ul><li><code>f::Polynomial</code>: The polynomial you need to check.</li><li><code>modulo::Int</code>: The modulus under which you are working.</li></ul><p>Returns:</p><ul><li><code>Bool</code>: Whether or not the polynomial is irreducible (true or false).</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; isirreducible(Polynomial([1, 1, 0, 0, 1]), 2) # is 1 + x + x^4 mod 2 irreducible?
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L238-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.islinear-Tuple{Array{T,1} where T,Int64}" href="#Main.CodingTheory.islinear-Tuple{Array{T,1} where T,Int64}"><code>Main.CodingTheory.islinear</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">islinear(C::Vector, modulo::Int; verbose::Bool = false) -&gt; Bool</code></pre><p>Determines whether a code <code>C</code> is a linear code (i.e., if it is closed under addition, scalar multiplication, and has the zero vector in it).</p><p>Parameters:</p><ul><li><code>C::Vector</code>: A code, typically consisting of multiple vectors or strings.</li><li><code>modulo::Int</code>: The modulus of the field under which you are working.</li><li><code>verbose::Bool</code> (kwarg): print the point at which C fails, if it does.</li></ul><p>Returns:</p><ul><li><code>Bool</code>: Whether or not the code <code>C</code> is linear (true or false).</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">
julia&gt; islinear([[0,0,0],[1,1,1],[1,0,1],[1,1,0]], 2) # checks whether a vector of vectors is linear/a subspace (modulo 2)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L180-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.isperfect-Union{Tuple{T}, NTuple{4,T}} where T&lt;:Int64" href="#Main.CodingTheory.isperfect-Union{Tuple{T}, NTuple{4,T}} where T&lt;:Int64"><code>Main.CodingTheory.isperfect</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isperfect(n::Int, k::Int, d::Int, q::Int) -&gt; Bool</code></pre><p>Checks if a code is perfect.  That is, checks if the number of words in the code is exactly the &quot;Hamming bound&quot;, or the &quot;Sphere Packing Bound&quot;.</p><p>Parameters:</p><ul><li><code>q:::Int</code>: The size of the alphabet of the code.</li><li><code>n::Int</code>: The length of the words in the code (block length).</li><li><code>d::Int</code>: The distance of the code.</li><li><code>k::Int</code>: The dimension of the code.</li></ul><p>Returns:</p><ul><li><code>Bool</code>: true or false</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; isperfect(11, 6, 5, 3)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L202-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.levenshtein-Tuple{AbstractString,AbstractString}" href="#Main.CodingTheory.levenshtein-Tuple{AbstractString,AbstractString}"><code>Main.CodingTheory.levenshtein</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">levenshtein(source::AbstractString, target::AbstractString) -&gt; Integer
levenshtein(source::AbstractString, target::AbstractString, cost::Real) -&gt; Integer
levenshtein(
    source::AbstractString,
    target::AbstractString,
    deletion_cost::R,
    insertion_cost::S,
    substitution_cost::T) -&gt; Integer
levenshtein!(
    source::AbstractString,
    target::AbstractString,
    deletion_cost::R,
    insertion_cost::S,
    substitution_cost::T,
    costs::Matrix = Array{promote_type(R, S, T)}(undef, 2, length(target) + 1)
) -&gt; Integer</code></pre><p>Computes the Levenshtein distance.</p><p><em>These methods are adapted from Levenshtein.jl, by Roger Tu.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/levenshtein.jl#L9-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.list_polys-Tuple{Int64,Int64}" href="#Main.CodingTheory.list_polys-Tuple{Int64,Int64}"><code>Main.CodingTheory.list_polys</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">list_polys(n::Int, m::Int) -&gt; Array</code></pre><p>Lists all polynomials of degree less than to <code>n</code> under modulo <code>m</code>.</p><p>Parameters:</p><ul><li><code>n::Int</code>: Highest degree of polynomial.</li><li><code>m::Int</code>: The modulus of the field.</li></ul><p>Returns:</p><ul><li><code>Array</code>: An array of polynomials of degree less than n, under modulo m.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L64-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.list_span-Tuple" href="#Main.CodingTheory.list_span-Tuple"><code>Main.CodingTheory.list_span</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">list_span(uÃ≤::Vector, vÃ≤::Vector,... modulo::Int) -&gt; Array</code></pre><p>Given any number of vectors <code>uÃ≤</code>, <code>vÃ≤</code>,... , prints all linear combinations of those vectors, modulo <code>modulo</code>.</p><p>Parameters:</p><ul><li><code>uÃ≤::Vector</code>: One vector.</li><li><code>vÃ≤::Vector</code>: Another vector.</li><li><code>...</code>: Other vectors.</li><li><code>modulo::Int</code>: The modulus of the field.</li></ul><p>Returns:</p><ul><li><code>Array</code>: All vectors in the span of uÃ≤ and vÃ≤, under modulo.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; list_span([2, 1, 1], [1, 1, 1], 3) # list the span of two vectors modulo 3
9-element Array{Array{T,1} where T,1}:
 [0, 0, 0]
 [1, 1, 1]
 [2, 2, 2]
 [2, 1, 1]
 [0, 2, 2]
 [1, 0, 0]
 [1, 2, 2]
 [2, 0, 0]
 [0, 1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L144-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.multiplication_table-Tuple{Int64,Int64}" href="#Main.CodingTheory.multiplication_table-Tuple{Int64,Int64}"><code>Main.CodingTheory.multiplication_table</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">multiplication_table(degree::Int, modulo::Int) -&gt; Matrix</code></pre><p>Returns a table (matrix) of the multiplication of all combinations of polynomials for degree less than <code>degree</code>, under modulo <code>modulo</code>.</p><p>Parameters:</p><ul><li><code>degree::Int</code>: Highest degree of polynomial.</li><li><code>modulo::Int</code>: The modulus of the field.</li></ul><p>Returns:</p><ul><li><code>Matrix</code>: A multiplication table of all polynomials with degree less than n, under modulus.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; julia&gt; multiplication_table(2, 3) # multiplication table of all polynomials of degree less than 3 modulo 2
9√ó9 Array{Polynomial,2}:
 Polynomial(0)  Polynomial(0)        Polynomial(0)        ‚Ä¶  Polynomial(0)                Polynomial(0)
 Polynomial(0)  Polynomial(1)        Polynomial(2)           Polynomial(1 + 2*x)          Polynomial(2 + 2*x)
 Polynomial(0)  Polynomial(2)        Polynomial(1)           Polynomial(2 + x)            Polynomial(1 + x)
 Polynomial(0)  Polynomial(x)        Polynomial(2*x)         Polynomial(x + 2*x^2)        Polynomial(2*x + 2*x^2)
 Polynomial(0)  Polynomial(1 + x)    Polynomial(2 + 2*x)     Polynomial(1 + 2*x^2)        Polynomial(2 + x + 2*x^2)
 Polynomial(0)  Polynomial(2 + x)    Polynomial(1 + 2*x)  ‚Ä¶  Polynomial(2 + 2*x + 2*x^2)  Polynomial(1 + 2*x^2)
 Polynomial(0)  Polynomial(2*x)      Polynomial(x)           Polynomial(2*x + x^2)        Polynomial(x + x^2)
 Polynomial(0)  Polynomial(1 + 2*x)  Polynomial(2 + x)       Polynomial(1 + x + x^2)      Polynomial(2 + x^2)
 Polynomial(0)  Polynomial(2 + 2*x)  Polynomial(1 + x)       Polynomial(2 + x^2)          Polynomial(1 + 2*x + x^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L82-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.mutate_codeword-Union{Tuple{N}, Tuple{T}, Tuple{Union{AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}},Int64,T}} where N where T" href="#Main.CodingTheory.mutate_codeword-Union{Tuple{N}, Tuple{T}, Tuple{Union{AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}},Int64,T}} where N where T"><code>Main.CodingTheory.mutate_codeword</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mutate_codeword(w::NonStaticAbstractWord{N, T}, n::Int, i::Int, a::T) where {T, N} -&gt; MVector{N, T}
mutate_codeword(w::Word{N, T}, n::Int, i::Int, a::T) where {T, N} -&gt; MVector{N, T}</code></pre><p>Mutates the word w, which is an <code>MVector</code> of length N, changing its i·µó ∞ index to a.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L415-L422">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.normal_form!-Tuple{AbstractArray{Int64,N} where N,Int64}" href="#Main.CodingTheory.normal_form!-Tuple{AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.normal_form!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normal_form!(M::AbstractArray{Int}, n::Int) -&gt; Matrix{Int}</code></pre><p>Convert a matrix M into normal form under modulo n via Gauss-Jordan elimination.  <em>This directly changes the matrix M.  Use <code>normal_form</code> for a non-mutating version of this function.</em></p><p>Parameters:</p><ul><li><code>M::AbstractArray{Int}</code>: A matrix of Ints.</li><li><code>n::Int</code>: The modulus of the finite field.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: A matrix in normal form from Gauss-Jordan elimination.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">
julia&gt; normal_form!([1 2 0 1 2 1 2; 2 2 2 0 1 1 1; 1 0 1 1 2 1 2; 0 1 0 1 1 2 2], 3) # computes rref colswap = false
4√ó7 Array{Int64,2}:
1  0  0  0  2  2  2
0  1  0  0  2  0  1
0  0  1  0  1  0  2
0  0  0  1  2  2  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L273-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.normal_form-Tuple{AbstractArray{Int64,N} where N,Int64}" href="#Main.CodingTheory.normal_form-Tuple{AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.normal_form</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">normal_form(M::AbstractArray{Int}, n::Int) -&gt; Matrix{Int}</code></pre><p>Convert a matrix M into normal form under modulo n via Gauss-Jordan elimination.</p><p>Parameters:</p><ul><li><code>M::AbstractArray{Int}</code>: A matrix of Ints.</li><li><code>n::Int</code>: The modulus of the finite field.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: A matrix in normal form from Gauss-Jordan elimination.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">
julia&gt; normal_form([1 2 0 1 2 1 2; 2 2 2 0 1 1 1; 1 0 1 1 2 1 2; 0 1 0 1 1 2 2], 3) # computes rref colswap = false
4√ó7 Array{Int64,2}:
1  0  0  0  2  2  2
0  1  0  0  2  0  1
0  0  1  0  1  0  2
0  0  0  1  2  2  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L305-L332">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.parity_check-Tuple{AbstractArray{Int64,N} where N,Int64}" href="#Main.CodingTheory.parity_check-Tuple{AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.parity_check</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parity_check(M::AbstractArray{Int}, n::Int) -&gt; Matrix{Int}</code></pre><p>Constructs a parity check matrix.  This is calculated from taking the non-identity part of a matrix in normal form (or equivalent &amp;mdash; see <code>generator</code>), transposing it, multiplying it by negative one, and appending to it an appropriate sized identity matrix.</p><p>Parameters:</p><ul><li><code>M::AbstractArray{Int}</code>: A matrix of Ints.</li><li><code>n::Int</code>: The modulus of the finite field.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: A parity check matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L438-L451">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.push_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1},T,Int64}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)" href="#Main.CodingTheory.push_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1},T,Int64}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.push_if_allowed!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">push_if_allowed!(C::AbstractArray{T}, C‚Ä≤::AbstractArray{T}, w::T, d::Int)</code></pre><p>Takes in two arrays, A and B.  If w is allowed in C given distance d, push to C‚Ä≤.  If we are successful in doing this, return true.  Otherwise, return false.  <em>This is a mutating function.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L369-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.push_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,T,Int64}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)" href="#Main.CodingTheory.push_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,T,Int64}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.push_if_allowed!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">push_if_allowed!(C::AbstractArray{T}, w::T, d::Int)</code></pre><p>Takes in an array and a word.  As long as the word does not mean that the distance is smaller than d, we add w to the array.  If we are successful in doing this, return true.  Otherwise, return false.  <em>This is a mutating function.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L349-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.rate-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Integer" href="#Main.CodingTheory.rate-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Integer"><code>Main.CodingTheory.rate</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rate(q::Integer, M::Integer, n::Integer) -&gt; Real</code></pre><p>Calculate the rate of a code.  That is, how efficient the code is.</p><p>Parameters:</p><ul><li><code>q::Integer</code>: the number of symbols in the code.</li><li><code>M::Integer</code>: the size/number of elements in the code.</li><li><code>n::Integer</code>: The word length.</li></ul><p>Returns:</p><ul><li><code>Real</code>: Rate of the code.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; rate(3, 5, 4) # the rate of the code which has 3 symbols, 5 words in the code, and word length of 4 (e.g., Œ£ = {A, B, C}, C = {ABBA,CABA,BBBB,CAAB,ACBB})
0.3662433801794817</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L10-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.replace_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T,1},Int64,Pair}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)" href="#Main.CodingTheory.replace_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T,1},Int64,Pair}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.replace_if_allowed!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">replace_if_allowed!(C::AbstractArray, d::Int, w, w‚Ä≤) -&gt; Bool</code></pre><p>Takes in an array and a word.  As long as the word does not mean that the distance is smaller than d, we replace a with b in the array.  Replaces and returns true if allowed; otherwise returns false.  <em>This is a mutating function.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L389-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.rref!-Tuple{Array{Int64,2},Int64}" href="#Main.CodingTheory.rref!-Tuple{Array{Int64,2},Int64}"><code>Main.CodingTheory.rref!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rref!(A::Matrix{Int}, n::Int; colswap::Bool=false, verbose::Bool=false, vverbose::Bool=false) -&gt; Matrix{Int}</code></pre><p>Performs Gauss-Jordan Elimination on a matrix <code>A</code>.  <em>This directly changes the matrix A.  Use <code>rref</code> for a non-mutating version of this function.</em></p><p>Parameters:</p><ul><li><code>A::Matrix{Int}</code>: A matrix of Ints you wish to perform Gauss-Jordan elimiation on.</li><li><code>n::Int</code>: The modulus of the finite field you are working under.</li><li><code>colswap::Bool</code> (kwarg): Whether or not you allow for column swapping.</li><li><code>verbose::Bool</code> (kwarg): Print the row operations.</li><li><code>vverbose::Bool</code> (kwarg): Print the intermediate matrices of the algorithm.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: a matrix in row echelon form.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; rref!([1 1 0 2 3 1; 2 0 1 3 4 1; 1 2 2 1 4 3], 5, colswap=true) # gauss-jordan elimitation modulo 5 with column swapping
3√ó6 Array{Int64,2}:
 1  0  0  3  2  2
 0  1  0  2  1  1
 0  0  1  0  0  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/rref.jl#L27-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.rref-Tuple{Array{Int64,2},Int64}" href="#Main.CodingTheory.rref-Tuple{Array{Int64,2},Int64}"><code>Main.CodingTheory.rref</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rref(A::Matrix{Int}, n::Int; colswap::Bool=false, verbose::Bool=false, vverbose::Bool=false) -&gt; Matrix{Int}</code></pre><p>Performs Gauss-Jordan Elimination on a matrix <code>A</code>.</p><p>Parameters:</p><ul><li><code>A::Matrix{Int}</code>: A matrix of Ints you wish to perform Gauss-Jordan elimiation on.</li><li><code>n::Int</code>: The modulus of the finite field you are working under.</li><li><code>colswap::Bool</code> (kwarg): Whether or not you allow for column swapping.</li><li><code>verbose::Bool</code> (kwarg): Print the row operations.</li><li><code>vverbose::Bool</code> (kwarg): Print the intermediate matrices of the algorithm.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: a matrix in row echelon form.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; rref([1 1 0 2 3 1; 2 0 1 3 4 1; 1 2 2 1 4 3], 5, colswap=true) # gauss-jordan elimitation modulo 5 with column swapping
3√ó6 Array{Int64,2}:
 1  0  0  3  2  2
 0  1  0  2  1  1
 0  0  1  0  0  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/rref.jl#L138-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.sizeof_all_words-Tuple{Int64,Int64}" href="#Main.CodingTheory.sizeof_all_words-Tuple{Int64,Int64}"><code>Main.CodingTheory.sizeof_all_words</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sizeof_all_words(q::Number, n::Number) -&gt; Number</code></pre><p>Calculates the number of gigabytes required to store all unique words of length n from an alphabet of size q.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L289-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.sizeof_perfect_code-Tuple{Int64,Int64,Int64}" href="#Main.CodingTheory.sizeof_perfect_code-Tuple{Int64,Int64,Int64}"><code>Main.CodingTheory.sizeof_perfect_code</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sizeof_perfect_code(q::Number, n::Number, d::Number) -&gt; Number</code></pre><p>Calculates the number of gigabytes required to store a perfect code of parameters q, n, and d.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/utils.jl#L277-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.sphere_covering_bound-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Integer" href="#Main.CodingTheory.sphere_covering_bound-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Integer"><code>Main.CodingTheory.sphere_covering_bound</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sphere_covering_bound(q::Integer, n::Integer, d::Integer) -&gt; Integer</code></pre><p>Computes the sphere covering bound of a <span>$[n, d]_q$</span>-code.</p><p>Parameters:</p><ul><li><code>q::Integer</code>: the number of symbols in the code.</li><li><code>n::Integer</code>: the word length.</li><li><code>d::Integer</code>: the distance of the code.</li></ul><p>Returns:</p><ul><li><code>Integer</code>: the sphere covering bound.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; sphere_covering_bound(5,7,3)
215</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L39-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.sphere_packing_bound-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Integer" href="#Main.CodingTheory.sphere_packing_bound-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Integer"><code>Main.CodingTheory.sphere_packing_bound</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sphere_packing_bound(q::Integer, n::Integer, d::Integer) -&gt; Integer
sphere_packing_bound(q::Integer, n::Integer, d::Integer, ::Rounding) -&gt; Real</code></pre><p>Computes the sphere packing bound of a <span>$[n, d]_q$</span>-code.  The sphere packing bound is also known as the hamming bound.  You can use <code>hamming_bound</code> to compute the same thing.</p><p>Parameters:</p><ul><li><code>q::Integer</code>: the number of symbols in the code.</li><li><code>n::Integer</code>: the word length.</li><li><code>d::Integer</code>: the distance of the code.</li><li><code>::Rounding</code>: use the argument <code>no_round</code> in this position to preserve the rounding of the code &amp;mdash; which usually by default rounds down.</li></ul><p>Returns:</p><ul><li><code>Integer</code>: the sphere packing bound.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; sphere_packing_bound(5,7,3)
2693</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/messages.jl#L65-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.syndrome-Tuple{Array{T,1} where T,AbstractArray{Int64,N} where N,Int64}" href="#Main.CodingTheory.syndrome-Tuple{Array{T,1} where T,AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.syndrome</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">syndrome(vÃ≤::Vector, H·µÄ::AbstractArray{Int}, n::Int) -&gt; Matrix{Int}</code></pre><p>Calculates the syndrome of a given word vÃ≤ and a parity check matrix, transposed (H·µÄ), under modulo n.</p><p>Parameters:</p><ul><li><code>vÃ≤::Vector</code>: A word in the code.</li><li><code>H·µÄ::AbstractArray{Int}</code>: The transpose of a parity check matrix.</li></ul><p>Returns:</p><ul><li><code>Vector</code>: The syndrome of a word in the code.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; syndrome([0, 2, 1, 2, 0, 1, 0], [1 1 1; 1 0 2; 2 0 1; 1 1 2; 1 0 0; 0 1 0; 0 0 1], 3)
1√ó3 Array{Int64,2}:
0  0  0

julia&gt; syndrome([0, 2, 1, 2, 0, 1, 0], transpose(parity_check([1 0 0 0 2 2 2; 0 1 0 0 2 0 1; 0 0 1 0 1 0 2; 0 0 0 1 2 2 1], 3)), 3)
1√ó3 Array{Int64,2}:
 0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/algebra.jl#L459-L486">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.t_error_correcting-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T&lt;:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}" href="#Main.CodingTheory.t_error_correcting-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T&lt;:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}"><code>Main.CodingTheory.t_error_correcting</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">t_error_correcting(C::AbstractArray{T}, t::Int) -&gt; Bool</code></pre><p>Check if a given code C can correct t many errors.</p><p>Parameters:</p><ul><li><code>C::AbstractArray</code>: An array of words in the code.</li><li><code>t::Int</code>: The number of errors you want to check that the code can correct.</li></ul><p>Returns:</p><ul><li>Bool: Yes, C can correct t errors, or no it cannot (true of false).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/distance.jl#L205-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Main.CodingTheory.t_error_detecting-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T&lt;:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}" href="#Main.CodingTheory.t_error_detecting-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T&lt;:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}"><code>Main.CodingTheory.t_error_detecting</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">t_error_detecting(C::AbstractArray{T}, t::Int) -&gt; Bool</code></pre><p>Check if a given code C can detect t many errors.</p><p>Parameters:</p><ul><li><code>C::AbstractArray</code>: An array of words in the code.</li><li><code>t::Int</code>: The number of errors you want to check that the code can detect.</li></ul><p>Returns:</p><ul><li><code>Bool</code>: Yes, C can detect t errors, or no it cannot (true of false).</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; t_error_detecting([[1, 0, 1], [0, 1, 1], [1, 0, 0]], 3)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/6c4ecd1ff5a980ee50ff3304b2ab80802359382b/src/distance.jl#L177-L199">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#Main.CodingTheory.AbstractCode"><code>Main.CodingTheory.AbstractCode</code></a></li><li><a href="#Main.CodingTheory.AbstractWord"><code>Main.CodingTheory.AbstractWord</code></a></li><li><a href="#Main.CodingTheory.Alphabet"><code>Main.CodingTheory.Alphabet</code></a></li><li><a href="#Main.CodingTheory.CodeUniverse"><code>Main.CodingTheory.CodeUniverse</code></a></li><li><a href="#Main.CodingTheory.CodeUniverseIterator"><code>Main.CodingTheory.CodeUniverseIterator</code></a></li><li><a href="#Main.CodingTheory.Codewords"><code>Main.CodingTheory.Codewords</code></a></li><li><a href="#Main.CodingTheory.FiniteField"><code>Main.CodingTheory.FiniteField</code></a></li><li><a href="#Main.CodingTheory.FinitePolynomial"><code>Main.CodingTheory.FinitePolynomial</code></a></li><li><a href="#Main.CodingTheory.NonStaticAbstractWord"><code>Main.CodingTheory.NonStaticAbstractWord</code></a></li><li><a href="#Main.CodingTheory.Rounding"><code>Main.CodingTheory.Rounding</code></a></li><li><a href="#Main.CodingTheory.UniverseParameters"><code>Main.CodingTheory.UniverseParameters</code></a></li><li><a href="#Main.CodingTheory.Word"><code>Main.CodingTheory.Word</code></a></li><li><a href="#Polynomials.Polynomial-Union{Tuple{T}, Tuple{N}, Tuple{Union{Array{T,1}, Tuple{Vararg{T,N}}},Int64}} where T where N"><code>Polynomials.Polynomial</code></a></li><li><a href="#Base.gensym-Tuple{Int64}"><code>Base.gensym</code></a></li><li><a href="#Base.mod-Tuple{Polynomials.Polynomial,Int64}"><code>Base.mod</code></a></li><li><a href="#Base.rand-Tuple{UniverseParameters,AbstractArray}"><code>Base.rand</code></a></li><li><a href="#Main.CodingTheory._has_identity-Union{Tuple{T}, Tuple{Array{T,2} where T,Union{AbstractRange{T}, Base.OneTo{T}, T}}} where T&lt;:Integer"><code>Main.CodingTheory._has_identity</code></a></li><li><a href="#Main.CodingTheory.allequal-Union{Tuple{Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}, Tuple{T}} where T"><code>Main.CodingTheory.allequal</code></a></li><li><a href="#Main.CodingTheory.allequal_length-Union{Tuple{Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}, Tuple{T}} where T"><code>Main.CodingTheory.allequal_length</code></a></li><li><a href="#Main.CodingTheory.aredistinct-Union{Tuple{Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}, Tuple{T}} where T"><code>Main.CodingTheory.aredistinct</code></a></li><li><a href="#Main.CodingTheory.areequalto-Union{Tuple{T}, Tuple{Any,Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}} where T"><code>Main.CodingTheory.areequalto</code></a></li><li><a href="#Main.CodingTheory.arelessthan-Union{Tuple{T}, Tuple{Number,Union{Tuple{Vararg{T,N}}, AbstractArray{T,N} where N} where N}} where T"><code>Main.CodingTheory.arelessthan</code></a></li><li><a href="#Main.CodingTheory.code_distance-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,T}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.code_distance</code></a></li><li><a href="#Main.CodingTheory.code_distance-Union{Tuple{AbstractArray{T,N} where N}, Tuple{T}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.code_distance</code></a></li><li><a href="#Main.CodingTheory.code_distance!-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,T}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.code_distance!</code></a></li><li><a href="#Main.CodingTheory.construct_ham_matrix-Tuple{Int64,Int64}"><code>Main.CodingTheory.construct_ham_matrix</code></a></li><li><a href="#Main.CodingTheory.deepeltype-Tuple{Any}"><code>Main.CodingTheory.deepeltype</code></a></li><li><a href="#Main.CodingTheory.deepsym-Tuple{Any}"><code>Main.CodingTheory.deepsym</code></a></li><li><a href="#Main.CodingTheory.displaymatrix-Tuple{AbstractArray}"><code>Main.CodingTheory.displaymatrix</code></a></li><li><a href="#Main.CodingTheory.ensure_symbolic-Tuple{Any}"><code>Main.CodingTheory.ensure_symbolic</code></a></li><li><a href="#Main.CodingTheory.ensure_symbolic!-Tuple{Any}"><code>Main.CodingTheory.ensure_symbolic!</code></a></li><li><a href="#Main.CodingTheory.equivalent_code-Tuple{AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.equivalent_code</code></a></li><li><a href="#Main.CodingTheory.equivalent_code!-Tuple{AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.equivalent_code!</code></a></li><li><a href="#Main.CodingTheory.find_error_correction_max-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T&lt;:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}"><code>Main.CodingTheory.find_error_correction_max</code></a></li><li><a href="#Main.CodingTheory.find_error_detection_max-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T&lt;:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}"><code>Main.CodingTheory.find_error_detection_max</code></a></li><li><a href="#Main.CodingTheory.genalphabet-Tuple{Int64}"><code>Main.CodingTheory.genalphabet</code></a></li><li><a href="#Main.CodingTheory.generator-Tuple{AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.generator</code></a></li><li><a href="#Main.CodingTheory.generator!-Tuple{AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.generator!</code></a></li><li><a href="#Main.CodingTheory.get_all_words-Union{Tuple{N}, Tuple{Alphabet{N},Int64,Int64}} where N"><code>Main.CodingTheory.get_all_words</code></a></li><li><a href="#Main.CodingTheory.get_codewords-Tuple{AbstractArray,Int64}"><code>Main.CodingTheory.get_codewords</code></a></li><li><a href="#Main.CodingTheory.get_codewords-Tuple{UniverseParameters,Int64}"><code>Main.CodingTheory.get_codewords</code></a></li><li><a href="#Main.CodingTheory.get_codewords_greedy-Tuple{UniverseParameters,Int64}"><code>Main.CodingTheory.get_codewords_greedy</code></a></li><li><a href="#Main.CodingTheory.get_codewords_random-Tuple{UniverseParameters,Int64}"><code>Main.CodingTheory.get_codewords_random</code></a></li><li><a href="#Main.CodingTheory.hamming_ball-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Array{S,1},Int64}} where S where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.hamming_ball</code></a></li><li><a href="#Main.CodingTheory.hamming_distance-Union{Tuple{T}, Tuple{T,T}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.hamming_distance</code></a></li><li><a href="#Main.CodingTheory.hamming_sphere-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T,N} where N,Array{S,1},Int64}} where S where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.hamming_sphere</code></a></li><li><a href="#Main.CodingTheory.has_identity-Tuple{Array{T,2} where T}"><code>Main.CodingTheory.has_identity</code></a></li><li><a href="#Main.CodingTheory.has_identity_on_left-Tuple{Array{T,2} where T}"><code>Main.CodingTheory.has_identity_on_left</code></a></li><li><a href="#Main.CodingTheory.isgolayperfect-Union{Tuple{T}, NTuple{4,T}} where T&lt;:Int64"><code>Main.CodingTheory.isgolayperfect</code></a></li><li><a href="#Main.CodingTheory.ishammingperfect-Tuple{Int64,Int64}"><code>Main.CodingTheory.ishammingperfect</code></a></li><li><a href="#Main.CodingTheory.ishammingperfect-Union{Tuple{T}, NTuple{4,T}} where T&lt;:Int64"><code>Main.CodingTheory.ishammingperfect</code></a></li><li><a href="#Main.CodingTheory.isincode-Tuple{Array{T,1} where T,AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.isincode</code></a></li><li><a href="#Main.CodingTheory.isirreducible-Tuple{Polynomials.Polynomial,Int64}"><code>Main.CodingTheory.isirreducible</code></a></li><li><a href="#Main.CodingTheory.islinear-Tuple{Array{T,1} where T,Int64}"><code>Main.CodingTheory.islinear</code></a></li><li><a href="#Main.CodingTheory.isperfect-Union{Tuple{T}, NTuple{4,T}} where T&lt;:Int64"><code>Main.CodingTheory.isperfect</code></a></li><li><a href="#Main.CodingTheory.levenshtein-Tuple{AbstractString,AbstractString}"><code>Main.CodingTheory.levenshtein</code></a></li><li><a href="#Main.CodingTheory.list_polys-Tuple{Int64,Int64}"><code>Main.CodingTheory.list_polys</code></a></li><li><a href="#Main.CodingTheory.list_span-Tuple"><code>Main.CodingTheory.list_span</code></a></li><li><a href="#Main.CodingTheory.multiplication_table-Tuple{Int64,Int64}"><code>Main.CodingTheory.multiplication_table</code></a></li><li><a href="#Main.CodingTheory.mutate_codeword-Union{Tuple{N}, Tuple{T}, Tuple{Union{AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}},Int64,T}} where N where T"><code>Main.CodingTheory.mutate_codeword</code></a></li><li><a href="#Main.CodingTheory.normal_form-Tuple{AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.normal_form</code></a></li><li><a href="#Main.CodingTheory.normal_form!-Tuple{AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.normal_form!</code></a></li><li><a href="#Main.CodingTheory.parity_check-Tuple{AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.parity_check</code></a></li><li><a href="#Main.CodingTheory.push_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T,1},AbstractArray{T,1},T,Int64}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.push_if_allowed!</code></a></li><li><a href="#Main.CodingTheory.push_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,T,Int64}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.push_if_allowed!</code></a></li><li><a href="#Main.CodingTheory.rate-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Integer"><code>Main.CodingTheory.rate</code></a></li><li><a href="#Main.CodingTheory.replace_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T,1},Int64,Pair}} where T&lt;:(Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N)"><code>Main.CodingTheory.replace_if_allowed!</code></a></li><li><a href="#Main.CodingTheory.rref-Tuple{Array{Int64,2},Int64}"><code>Main.CodingTheory.rref</code></a></li><li><a href="#Main.CodingTheory.rref!-Tuple{Array{Int64,2},Int64}"><code>Main.CodingTheory.rref!</code></a></li><li><a href="#Main.CodingTheory.sizeof_all_words-Tuple{Int64,Int64}"><code>Main.CodingTheory.sizeof_all_words</code></a></li><li><a href="#Main.CodingTheory.sizeof_perfect_code-Tuple{Int64,Int64,Int64}"><code>Main.CodingTheory.sizeof_perfect_code</code></a></li><li><a href="#Main.CodingTheory.sphere_covering_bound-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Integer"><code>Main.CodingTheory.sphere_covering_bound</code></a></li><li><a href="#Main.CodingTheory.sphere_packing_bound-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Integer"><code>Main.CodingTheory.sphere_packing_bound</code></a></li><li><a href="#Main.CodingTheory.syndrome-Tuple{Array{T,1} where T,AbstractArray{Int64,N} where N,Int64}"><code>Main.CodingTheory.syndrome</code></a></li><li><a href="#Main.CodingTheory.t_error_correcting-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T&lt;:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}"><code>Main.CodingTheory.t_error_correcting</code></a></li><li><a href="#Main.CodingTheory.t_error_detecting-Union{Tuple{T}, Tuple{AbstractArray{T,N} where N,Int64}} where T&lt;:Union{AbstractArray{Int64,N} where N, Union{Word{N,T}, AbstractArray{T,1}, AbstractString, Tuple{Vararg{T,N}}, StaticArrays.MArray{Tuple{N},T,1,N}} where T where N}"><code>Main.CodingTheory.t_error_detecting</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 12 January 2021 06:24">Tuesday 12 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
