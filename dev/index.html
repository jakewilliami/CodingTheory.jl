<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Index ¬∑ CodingTheory Documentation</title><meta name="title" content="Index ¬∑ CodingTheory Documentation"/><meta property="og:title" content="Index ¬∑ CodingTheory Documentation"/><meta property="twitter:title" content="Index ¬∑ CodingTheory Documentation"/><meta name="description" content="Documentation for CodingTheory Documentation."/><meta property="og:description" content="Documentation for CodingTheory Documentation."/><meta property="twitter:description" content="Documentation for CodingTheory Documentation."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>CodingTheory Documentation</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Index</a><ul class="internal"><li><a class="tocitem" href="#Adding-CodingTheory.jl"><span>Adding CodingTheory.jl</span></a></li><li><a class="tocitem" href="#Documentation"><span>Documentation</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Index</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Index</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/jakewilliami/CodingTheory.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/jakewilliami/CodingTheory.jl/blob/master/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="CodingTheory.jl-Documentation"><a class="docs-heading-anchor" href="#CodingTheory.jl-Documentation">CodingTheory.jl Documentation</a><a id="CodingTheory.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#CodingTheory.jl-Documentation" title="Permalink"></a></h1><ul><li><a href="#CodingTheory.jl-Documentation">CodingTheory.jl Documentation</a></li><li class="no-marker"><ul><li><a href="#Adding-CodingTheory.jl">Adding CodingTheory.jl</a></li><li><a href="#Documentation">Documentation</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Adding-CodingTheory.jl"><a class="docs-heading-anchor" href="#Adding-CodingTheory.jl">Adding CodingTheory.jl</a><a id="Adding-CodingTheory.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-CodingTheory.jl" title="Permalink"></a></h2><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Pkg</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Pkg.add(&quot;CodingTheory&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">    Updating registry at `~/.julia/registries/General.toml`
   Resolving package versions...
   Installed OffsetArrays ‚îÄ v1.14.1
   Installed CodingTheory ‚îÄ v0.2.2
   Installed Polynomials ‚îÄ‚îÄ v1.2.1
    Updating `~/work/CodingTheory.jl/CodingTheory.jl/docs/Project.toml`
  [89c41d41] ~ CodingTheory v0.2.3 `~/work/CodingTheory.jl/CodingTheory.jl` ‚áí v0.2.2
    Updating `~/work/CodingTheory.jl/CodingTheory.jl/docs/Manifest.toml`
  [c3fe647b] - AbstractAlgebra v0.24.1
  [89c41d41] ~ CodingTheory v0.2.3 `~/work/CodingTheory.jl/CodingTheory.jl` ‚áí v0.2.2
  [d5909c97] - GroupsCore v0.4.2
  [3e1990a7] - Hecke v0.10.29
  [d8a4904e] - MutableArithmetics v1.5.2
  [2edaba10] - Nemo v0.29.2
  [6fe1bfb0] + OffsetArrays v1.14.1
‚åÖ [f27b6e38] ‚Üì Polynomials v2.0.25 ‚áí v1.2.1
  [fb686558] - RandomExtensions v0.4.4
  [e21ec000] - Antic_jll v0.200.501+0
  [d9960996] - Arb_jll v200.2200.0+0
  [fcfa6d1b] - Calcium_jll v0.400.102+0
  [e134572f] - FLINT_jll v200.800.500+0
  [656ef2d0] - OpenBLAS32_jll v0.3.28+3
  [9abbd945] - Profile v1.11.0
  [781609d7] - GMP_jll v6.3.0+0
  [3a97d323] - MPFR_jll v4.2.1+0
        Info Packages marked with ‚åÖ have new versions available but compatibility constraints restrict them from upgrading. To see why use `status --outdated -m`
Precompiling project...
   1601.6 ms  ‚úì OffsetArrays
   2795.5 ms  ‚úì Polynomials
   2725.4 ms  ‚úì CodingTheory
  3 dependencies successfully precompiled in 8 seconds. 114 already precompiled.
  2 dependencies precompiled but different versions are currently loaded. Restart julia to access the new versions
  1 dependency had output during precompilation:
‚îå Polynomials
‚îÇ  WARNING: method definition for showterm at /home/runner/.julia/packages/Polynomials/1aa8e/src/polynomials/ChebyshevT.jl:224 declares type variable N but does not use it.
‚îî</code></pre><h2 id="Documentation"><a class="docs-heading-anchor" href="#Documentation">Documentation</a><a id="Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Documentation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.AbstractWord" href="#CodingTheory.AbstractWord"><code>CodingTheory.AbstractWord</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractWord{N} = Union{NonStaticAbstractWord{N, T}, MVector{T}} where {T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/abstract_types.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.NonStaticAbstractWord" href="#CodingTheory.NonStaticAbstractWord"><code>CodingTheory.NonStaticAbstractWord</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">NonStaticAbstractWord{N, T} = Union{NTuple{N, T}, AbstractVector{T}, AbstractString} where {N, T}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/abstract_types.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.AbstractCode" href="#CodingTheory.AbstractCode"><code>CodingTheory.AbstractCode</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type AbstractCode end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/abstract_types.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.Alphabet" href="#CodingTheory.Alphabet"><code>CodingTheory.Alphabet</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Alphabet &lt;: AbstractCode</code></pre><p>Has the parameter Œ£, which is the alphabet; a collection of strings, characters, symbols, or Ints.</p><hr/><pre><code class="language-julia hljs">Alphabet(Œ£::AbstractArray)</code></pre><p>A constructor method for the struct Alphabet.  Takes an array of letters in the alphabet, and attempts to parse them as 64-bit Ints.</p><hr/><pre><code class="language-julia hljs">Alphabet{N}(Œ£::AbstractArray)
Alphabet{N}(Œ£::AbstractString)</code></pre><p>A constructor method for the struct Alphabet.  Takes in a symbols and splits it into constituent characters.  Those symbols are the letters in the alphabet.  <code>N</code> is the number of letters in the alphabet</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/abstract_types.jl#L78-L101">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.CodeUniverse" href="#CodingTheory.CodeUniverse"><code>CodingTheory.CodeUniverse</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct CodeUniverse &lt;: AbstractCode</code></pre><p>Defines a structure for the messages in the code.  Parameters are the abstract array of messages <code>ùí∞</code>, and the length of the messages <code>n</code>.</p><pre><code class="language-julia hljs">CodeUniverse(ùí∞::AbstractArray, Œ£::Alphabet)</code></pre><p>An inner constructor function on the structure <code>CodeUniverse</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/abstract_types.jl#L236-L248">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.CodeUniverseIterator" href="#CodingTheory.CodeUniverseIterator"><code>CodingTheory.CodeUniverseIterator</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct CodeUniverseIterator &lt;: AbstractCode</code></pre><p>A structure used to iterate through a code universe, with specified universe parameters.  E.g.,</p><pre><code class="language-julia hljs">for c in CodeUniverseIterator([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 3)
    println(c)
end</code></pre><p>Fields:</p><ul><li><code>ùí∞::UniverseParameters</code></li></ul><p>Methods:</p><pre><code class="language-julia hljs">CodeUniverseIterator(ùí∞::UniverseParameters)
CodeUniverseIterator(Œ£::Union{Alphabet, AbstractArray}, q::Int, n::Int)
CodeUniverseIterator(Œ£::Union{Alphabet, AbstractArray}, n::Int)
CodeUniverseIterator(q::Int, n::Int)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/abstract_types.jl#L190-L214">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.Codewords" href="#CodingTheory.Codewords"><code>CodingTheory.Codewords</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Codewords{N} &lt;: AbstractCode</code></pre><p>Simply a wrapper type for a vector of abstract words of length <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/abstract_types.jl#L68-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.FiniteField" href="#CodingTheory.FiniteField"><code>CodingTheory.FiniteField</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">abstract type FiniteField end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/abstract_types.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.FinitePolynomial" href="#CodingTheory.FinitePolynomial"><code>CodingTheory.FinitePolynomial</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct FinitePolynomial &lt;: FiniteField</code></pre><p>Has parameters <code>p</code>, which is an abstract polynomial, and <code>n</code> which is the modulus of the field under which the molynomial is defined.</p><hr/><pre><code class="language-julia hljs">FinitePolynomial(p::AbstractPolynomial, n::Int)</code></pre><p>A constructor method for <code>FinitePolynomial</code>.  Takes in a polynomial <code>p</code> and a number <code>n</code>, and constructs a polynomial under modulo n.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.Rounding" href="#CodingTheory.Rounding"><code>CodingTheory.Rounding</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct Rounding end</code></pre><p>An abstract structure used as a parameter in a non-rounding method of <code>hamming_bound</code>.  Use <code>no_round</code> for this; a predefiend variable of the structure <code>Rounding</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/abstract_types.jl#L263-L269">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.UniverseParameters" href="#CodingTheory.UniverseParameters"><code>CodingTheory.UniverseParameters</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">struct UniverseParameters &lt;: AbstractCode</code></pre><p>Defines a structure for the messages in the code.  Parameters are the alphabet <code>Œ£</code>, size of alphabet <code>q</code>, and block length <code>n</code></p><pre><code class="language-julia hljs">UniverseParameters(Œ£::Alphabet, n::Int)
UniverseParameters(Œ£::AbstractArray, n::Int)
UniverseParameters(Œ£::Alphabet, q::Int, n::Int)
UniverseParameters(Œ£::AbstractArray, q::Int, n::Int)
UniverseParameters(q::Int, n::Int)</code></pre><p>An inner constructor function on the structure <code>UniverseParameters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/abstract_types.jl#L140-L156">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.Word" href="#CodingTheory.Word"><code>CodingTheory.Word</code></a> ‚Äî <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutable struct Word{N, T}
Word(w::NTuple{N, T})
Word(w::AbstractVector{T})
Word(w::AbstractString)
Word(i::T...)</code></pre><p>A Word is an <code>StaticArrays.MVector</code> which is efficient (like tuple) yet mutable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/abstract_types.jl#L23-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Polynomials.Polynomial-Union{Tuple{T}, Tuple{N}, Tuple{Union{Vector{T}, NTuple{N, T}}, Int64}} where {N, T}" href="#Polynomials.Polynomial-Union{Tuple{T}, Tuple{N}, Tuple{Union{Vector{T}, NTuple{N, T}}, Int64}} where {N, T}"><code>Polynomials.Polynomial</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Polynomial(A::Union{NTuple{N, T}, Vector{T}}, n::Int) -&gt; Polynomial</code></pre><p>Constructs a polynomial under modulo <code>n</code>.</p><p>Parameters:</p><ul><li><code>A::Union{Tuple, AbstractArray}</code>: The polynomial coefficients.</li><li><code>n::Int</code>: The modulus of the field.</li></ul><p>Returns</p><ul><li><code>Polynomial</code>: A polynomial modulo n.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L42-L55">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.gensym-Tuple{Int64}" href="#Base.gensym-Tuple{Int64}"><code>Base.gensym</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">gensym(q::Int) -&gt; Vector{Symbol}</code></pre><p>Generates a vector of unique symbols of length q.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/abstract_types.jl#L122-L128">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.mod-Tuple{Polynomials.Polynomial, Int64}" href="#Base.mod-Tuple{Polynomials.Polynomial, Int64}"><code>Base.mod</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mod(p::Polynomial, n::Int) -&gt; Polynomial</code></pre><p>Uses the <code>FinitePolynomial</code> constructor to return a polynomial <code>p</code> under modulus <code>n</code>.</p><p>Parameters:</p><ul><li><code>p::Polynomial</code>: The input polynomial.</li><li><code>n::Int</code>: The modulus of the field.</li></ul><p>Returns</p><ul><li>Polynomial: A polynomial modulo n.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L26-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand-Tuple{UniverseParameters, AbstractArray}" href="#Base.rand-Tuple{UniverseParameters, AbstractArray}"><code>Base.rand</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand(ùí∞::UniverseParameters, C::AbstractArray) -&gt; Tuple</code></pre><p>Given universe parameters ùí∞ and a code C, return a tuple including</p><ul><li>A random word in C;</li><li>A random letter in the alphabet; and</li><li>A random index in the block length.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/abstract_types.jl#L177-L186">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory._has_identity-Union{Tuple{T}, Tuple{Matrix, Union{AbstractRange{T}, Base.OneTo{T}, T}}} where T&lt;:Integer" href="#CodingTheory._has_identity-Union{Tuple{T}, Tuple{Matrix, Union{AbstractRange{T}, Base.OneTo{T}, T}}} where T&lt;:Integer"><code>CodingTheory._has_identity</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">_has_identity(M::Matrix, n::Union{T, Base.OneTo{T}, AbstractRange{T}}) where {T &lt;: Integer}</code></pre><p>Inner function on <code>has_identity</code> function.  Will return a tuple of:</p><ul><li>Whether or not the matrix has an identity;</li><li>Where that identity matrix starts; and</li><li>How big the identity matrix is.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L152-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.allequal-Union{Tuple{Union{NTuple{N, T}, AbstractArray{T}} where N}, Tuple{T}} where T" href="#CodingTheory.allequal-Union{Tuple{Union{NTuple{N, T}, AbstractArray{T}} where N}, Tuple{T}} where T"><code>CodingTheory.allequal</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allequal(A) -&gt; Bool
allequal(a, b...) -&gt; Bool</code></pre><p>Check that all elements in a list are equal to each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L36-L43">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.allequal_length-Union{Tuple{Union{NTuple{N, T}, AbstractArray{T}} where N}, Tuple{T}} where T" href="#CodingTheory.allequal_length-Union{Tuple{Union{NTuple{N, T}, AbstractArray{T}} where N}, Tuple{T}} where T"><code>CodingTheory.allequal_length</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">allequal_length(A) -&gt; Bool
allequal_length(a, b...) -&gt; Bool</code></pre><p>Check that all elements in a list are of equal length.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L17-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.aredistinct-Union{Tuple{Union{NTuple{N, T}, AbstractArray{T}} where N}, Tuple{T}} where T" href="#CodingTheory.aredistinct-Union{Tuple{Union{NTuple{N, T}, AbstractArray{T}} where N}, Tuple{T}} where T"><code>CodingTheory.aredistinct</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">aredistinct(A) -&gt; Bool
aredistinct(a, b...) -&gt; Bool</code></pre><p>Check that all elements in a list are distinct from every other element in the list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L59-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.areequalto-Union{Tuple{T}, Tuple{Any, Union{NTuple{N, T}, AbstractArray{T}} where N}} where T" href="#CodingTheory.areequalto-Union{Tuple{T}, Tuple{Any, Union{NTuple{N, T}, AbstractArray{T}} where N}} where T"><code>CodingTheory.areequalto</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">areequalto(x::Number, A::AbstractArray) -&gt; Bool
areequalto(x::Number, a, b...) -&gt; Bool</code></pre><p>Check that all elements in a list are equal to a given x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L96-L103">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.arelessthan-Union{Tuple{T}, Tuple{Number, Union{NTuple{N, T}, AbstractArray{T}} where N}} where T" href="#CodingTheory.arelessthan-Union{Tuple{T}, Tuple{Number, Union{NTuple{N, T}, AbstractArray{T}} where N}} where T"><code>CodingTheory.arelessthan</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">arelessthan(x::Number, A) -&gt; Bool
arelessthan(x::Number, a, b...) -&gt; Bool</code></pre><p>Check that all elements in a list are less than a given x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L79-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.code_distance!-Union{Tuple{T}, Tuple{AbstractArray{T}, T}} where T&lt;:(AbstractWord)" href="#CodingTheory.code_distance!-Union{Tuple{T}, Tuple{AbstractArray{T}, T}} where T&lt;:(AbstractWord)"><code>CodingTheory.code_distance!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">code_distance!(C::AbstractArray{T}, w::T) -&gt; Int</code></pre><p>A wrapper to get the code distance after pushing a word to the code.  <em>This directly changes the matrix M.  Use <code>code_distance</code> for a non-mutating version of this function.</em></p><p>Parameters:</p><ul><li><code>C::AbstractArray</code>: An array of words in the code.</li><li><code>w</code>: A word to be appended to C.</li></ul><p>Returns:</p><ul><li><code>Int</code>: The code distance after adding w to C.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/distance.jl#L134-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.code_distance-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:(AbstractWord)" href="#CodingTheory.code_distance-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:(AbstractWord)"><code>CodingTheory.code_distance</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">code_distance(C::AbstractArray) -&gt; Int</code></pre><p>Finds the distance of the code.  That is, given a code C, finds the minimum distance between any two words in the code, which are not the same. (Find the minimum hamming distance in the code for all unique letters).</p><p>Parameters:</p><ul><li><code>C::AbstractArray</code>: An array of words in the code.</li></ul><p>Return:</p><ul><li><code>Int</code>: the distance of the code.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/distance.jl#L102-L116">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.code_distance-Union{Tuple{T}, Tuple{AbstractArray{T}, T}} where T&lt;:(AbstractWord)" href="#CodingTheory.code_distance-Union{Tuple{T}, Tuple{AbstractArray{T}, T}} where T&lt;:(AbstractWord)"><code>CodingTheory.code_distance</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">code_distance(C::AbstractArray{T}, w::T) -&gt; Int</code></pre><p>A wrapper to get the code distance after pushing a word to the code.</p><p>Parameters:</p><ul><li><code>C::AbstractArray</code>: An array of words in the code.</li><li><code>w</code>: A word to be appended to C.</li></ul><p>Returns:</p><ul><li><p><code>Int</code>: The code distance after adding w to C.</p></li><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; code_distance([[0, 0, 0, 0, 0], [1, 0, 1, 0, 1], [0, 1, 0, 1, 0], [1, 1, 1, 1, 1]]) # gets the minimum distance between two vectors in an array of vectors
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/distance.jl#L155-L179">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.construct_ham_matrix-Tuple{Int64, Int64}" href="#CodingTheory.construct_ham_matrix-Tuple{Int64, Int64}"><code>CodingTheory.construct_ham_matrix</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">construct_ham_matrix(r::Int, q::Int) -&gt; Matrix</code></pre><p>Construct a Hamming parity-check matrix.</p><p>Parameters:</p><ul><li><code>r::Int</code>: number of rows of a parity check matrix.</li><li><code>q:::Int</code>: The size of the alphabet of the code.</li></ul><p>Returns:</p><ul><li><code>Matrix</code>: The Hamming matrix, denoted as <span>$\text{Ham}(r, q)$</span></li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; construct_ham_matrix(3,2)
3√ó7 Array{Int64,2}:
 0  0  0  1  1  1  1
 0  1  1  0  0  1  1
 1  0  1  0  1  0  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/bounds.jl#L176-L201">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.deepeltype-Tuple{Any}" href="#CodingTheory.deepeltype-Tuple{Any}"><code>CodingTheory.deepeltype</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deepeltype(a::AbstractArray) -&gt; Type</code></pre><p>Returns the type of the inner-most element in a nested array structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L123-L129">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.deepsym-Tuple{Any}" href="#CodingTheory.deepsym-Tuple{Any}"><code>CodingTheory.deepsym</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">deepsym(a::AbstractArray)</code></pre><p>Convert inner-most elements into symbols</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L113-L119">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.displaymatrix-Tuple{AbstractArray}" href="#CodingTheory.displaymatrix-Tuple{AbstractArray}"><code>CodingTheory.displaymatrix</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">displaymatrix(M::AbstractArray)</code></pre><p>Displays a matrix <code>M</code> in a compact form from the terminal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.ensure_symbolic!-Tuple{Any}" href="#CodingTheory.ensure_symbolic!-Tuple{Any}"><code>CodingTheory.ensure_symbolic!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ensure_symbolic!(Œ£) -&gt; typeof(Œ£)</code></pre><p>Ensures that the inner-most elements of a nested array structure are of the type <code>Symbol</code>.  <em>This is a mutating function.  Use its twin, non-mutating function, <code>ensure_symbolic</code>, if you need a non-mutating version of this.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L134-L140">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.ensure_symbolic-Tuple{Any}" href="#CodingTheory.ensure_symbolic-Tuple{Any}"><code>CodingTheory.ensure_symbolic</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ensure_symbolic(Œ£) -&gt; typeof(Œ£)</code></pre><p>Ensures that the inner-most elements of a nested array structure are of the type <code>Symbol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L143-L149">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.equivalent_code!-Tuple{AbstractArray{Int64}, Int64}" href="#CodingTheory.equivalent_code!-Tuple{AbstractArray{Int64}, Int64}"><code>CodingTheory.equivalent_code!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">equivalent_code!(M::AbstractArray{Int}, n::Int) -&gt; Matrix{Int}</code></pre><p>Peforms Gauss-Jordan elimination on a matrix M, but allows for column swapping.  This constructs an &quot;equivalent&quot; matrix.  <em>This directly changes the matrix M.  Use <code>equivalent_code</code> for a non-mutating version of this function.</em></p><p>Parameters:</p><ul><li><code>M::AbstractArray{Int}</code>: A matrix of Ints.</li><li><code>n::Int</code>: The modulus of the finite field.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: A which represents an &quot;equivalent&quot; code to that of the matrix M.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; equivalent_code!([1 2 0 1 2 1 2; 2 2 2 0 1 1 1; 1 0 1 1 2 1 2; 0 1 0 1 1 2 2], 3) # computes rref colswap = true
4√ó7 Array{Int64,2}:
1  0  0  0  2  2  2
0  1  0  0  2  0  1
0  0  1  0  1  0  2
0  0  0  1  2  2  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L333-L360">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.equivalent_code-Tuple{AbstractArray{Int64}, Int64}" href="#CodingTheory.equivalent_code-Tuple{AbstractArray{Int64}, Int64}"><code>CodingTheory.equivalent_code</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">equivalent_code(M::AbstractArray{Int}, n::Int) -&gt; Matrix{Int}</code></pre><p>Peforms Gauss-Jordan elimination on a matrix M, but allows for column swapping.</p><p>Parameters:</p><ul><li><code>M::AbstractArray{Int}</code>: A matrix of Ints.</li><li><code>n::Int</code>: The modulus of the finite field.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: A which represents an &quot;equivalent&quot; code to that of the matrix M.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; equivalent_code([1 2 0 1 2 1 2; 2 2 2 0 1 1 1; 1 0 1 1 2 1 2; 0 1 0 1 1 2 2], 3) # computes rref colswap = true
4√ó7 Array{Int64,2}:
1  0  0  0  2  2  2
0  1  0  0  2  0  1
0  0  1  0  1  0  2
0  0  0  1  2  2  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L365-L391">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.find_error_correction_max-Union{Tuple{T}, Tuple{AbstractArray{T}, Int64}} where T&lt;:Union{AbstractString, Word, AbstractArray{Int64}, AbstractVector, NTuple{N, T} where {N, T}}" href="#CodingTheory.find_error_correction_max-Union{Tuple{T}, Tuple{AbstractArray{T}, Int64}} where T&lt;:Union{AbstractString, Word, AbstractArray{Int64}, AbstractVector, NTuple{N, T} where {N, T}}"><code>CodingTheory.find_error_correction_max</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_error_correction_max(C::AbstractArray{T}, modulo::Int) -&gt; Int</code></pre><p>Finds the greatest number t such that C is error t error correcting.</p><p>Parameters:</p><ul><li><code>C::AbstractArray</code>: An array of words in the code.</li><li><code>moldulo::Int</code>: The modulus of the finite field.  The upper bound of t.</li></ul><p>Returns:</p><ul><li><code>Int</code>: The maximum number t such that the code is t error correcting.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/distance.jl#L270-L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.find_error_detection_max-Union{Tuple{T}, Tuple{AbstractArray{T}, Int64}} where T&lt;:Union{AbstractString, Word, AbstractArray{Int64}, AbstractVector, NTuple{N, T} where {N, T}}" href="#CodingTheory.find_error_detection_max-Union{Tuple{T}, Tuple{AbstractArray{T}, Int64}} where T&lt;:Union{AbstractString, Word, AbstractArray{Int64}, AbstractVector, NTuple{N, T} where {N, T}}"><code>CodingTheory.find_error_detection_max</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">find_error_detection_max(C::AbstractArray{T}, modulo::Int) -&gt; Int</code></pre><p>Finds the greatest number t such that C is error t error detecting.</p><p>Parameters:</p><ul><li><code>C::AbstractArray</code>: An array of words in the code.</li><li><code>moldulo::Int</code>: The modulus of the finite field.  The upper bound of t.</li></ul><p>Returns:</p><ul><li><p><code>Int</code>: The maximum number t such that the code is t error detecting.</p></li><li><ul><li><ul><li></li></ul></li></ul></li></ul><pre><code class="language-julia hljs">julia&gt; find_error_detection_max([[0, 0, 0, 0], [0, 1, 1, 1], [1, 0, 1, 0], [1, 1, 0, 1]], 2)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/distance.jl#L239-L261">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.genalphabet-Tuple{Int64}" href="#CodingTheory.genalphabet-Tuple{Int64}"><code>CodingTheory.genalphabet</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">genalphabet(q::Int)</code></pre><p>Generates an alphabet of q unique symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/abstract_types.jl#L131-L137">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.generator!-Tuple{AbstractArray{Int64}, Int64}" href="#CodingTheory.generator!-Tuple{AbstractArray{Int64}, Int64}"><code>CodingTheory.generator!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generator!(M::AbstractArray{Int}, n::Int; colswap::Bool = true) -&gt; Matrix{Int}</code></pre><p>Constructs a generator matrix of the code, depending on if you allow for column swapping or not.   This function uses <code>normal_form!</code> or <code>equivalent_code!</code>.  <em>This directly changes the matrix M.  Use <code>generator</code> for a non-mutating version of this function.</em></p><p>Parameters:</p><ul><li><code>M::AbstractArray{Int}</code>: A matrix of Ints.</li><li><code>n::Int</code>: The modulus of the finite field.</li><li><code>colswap::Bool</code> (kwarg): A boolean flag indicating whether or not you allow for swapping of columns when constructing the generating matrix.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: A generating matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L396-L410">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.generator-Tuple{AbstractArray{Int64}, Int64}" href="#CodingTheory.generator-Tuple{AbstractArray{Int64}, Int64}"><code>CodingTheory.generator</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">generator(M::AbstractArray{Int}, n::Int; colswap::Bool = true) -&gt; Matrix{Int}</code></pre><p>Constructs a generator matrix of the code, depending on if you allow for column swapping or not.  This function uses <code>normal_form</code> or <code>equivalent_code</code>.</p><p>Parameters:</p><ul><li><code>M::AbstractArray{Int}</code>: A matrix of Ints.</li><li><code>n::Int</code>: The modulus of the finite field.</li><li><code>colswap::Bool</code> (kwarg): A boolean flag indicating whether or not you allow for swapping of columns when constructing the generating matrix.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: A generating matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L415-L429">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.get_all_words-Union{Tuple{N}, Tuple{Alphabet{N}, Int64, Int64}} where N" href="#CodingTheory.get_all_words-Union{Tuple{N}, Tuple{Alphabet{N}, Int64, Int64}} where N"><code>CodingTheory.get_all_words</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_all_words(Œ£::Alphabet{N}, q::Int, n::Int) -&gt; Codewords{M}
get_all_words(Œ£::Alphabet{N}, n::Int) -&gt; Codewords{M}
get_all_words(Œ£::AbstractArray, q::Int, n::Int) -&gt; Codewords{M}
get_all_words(Œ£::AbstractArray, n::Int) -&gt; Codewords{M}
get_all_words(q::Int, n::Int) -&gt; Codewords{M}</code></pre><p>Get the universe of <em>all</em> codewords of a given alphabet.  The alphabet will be uniquely generated if none is given.</p><p>Parameters:</p><ul><li><code>Œ£::AbstractArray</code>: The alphabet allowed.</li><li><code>q::Int</code>: The size of the alphabet.</li><li><code>n::Int</code>: The (fixed) length of the words in the code.</li><li><code>d::Int</code>: The minimum distance between words in the code.</li><li><code>ùí∞::AbstractArray</code>: The universe of all codewords of q many letters of block length n.</li></ul><p>Returns:</p><ul><li><p><code>Codewords{M}</code>: An array of codewords, each of length <code>M</code>.  Each codewords is a tuple, and each character in said word is a symbol.</p></li><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; get_all_words(2, 2) # all words of block length 2 using 2 unique symbols
2√ó2 Array{Tuple{Symbol,Symbol},2}:
 (Symbol(&quot;##254&quot;), Symbol(&quot;##254&quot;))  (Symbol(&quot;##254&quot;), Symbol(&quot;##253&quot;))
 (Symbol(&quot;##253&quot;), Symbol(&quot;##254&quot;))  (Symbol(&quot;##253&quot;), Symbol(&quot;##253&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/messages.jl#L90-L123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.get_codewords-Tuple{AbstractArray, Int64}" href="#CodingTheory.get_codewords-Tuple{AbstractArray, Int64}"><code>CodingTheory.get_codewords</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_codewords(G::AbstractArray, m::Int) -&gt; Codewords{M}</code></pre><p>Get codewords of a code from the <em>generating matrix</em> under a finite field of modulo <code>m</code>.  Precisely, computes all linear combinations of the rows of the generating matrix.</p><p>Parameters:</p><ul><li><code>G::AbstractArray</code>: A matrix of Ints which generates the code.</li><li><code>m::Int</code>: The bounds of the finite field (i.e., the molulus you wish to work in).</li></ul><p>Returns:</p><ul><li><code>Codewords{M}</code>: An array of codewords, each of length <code>M</code>.  Each codewords is a tuple, and each character in said word is a symbol.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/messages.jl#L418-L433">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.get_codewords-Tuple{UniverseParameters, Int64}" href="#CodingTheory.get_codewords-Tuple{UniverseParameters, Int64}"><code>CodingTheory.get_codewords</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_codewords(ùí∞::UniverseParameters, d::Int; m::Int = 10, m_random::Int = 1000) -&gt;
    Codewords{M}
get_codewords(Œ£::Alphabet{N}, q::Int, n::Int, d::Int; m::Int = 10, m_random::Int = 1000) -&gt;
    Codewords{M}
get_codewords(q::Int, n::Int, d::Int; m::Int = 10, m_random::Int = 1000) -&gt; Codewords{M}
get_codewords(q::Int, n::Int, d::Int; m::Int = 10, m_random::Int = 1000) -&gt; Codewords{M}
get_codewords(
    Œ£::AbstractArray, q::Int, n::Int, d::Int; m::Int = 10, m_random::Int = 1000
) -&gt; Codewords{M}
get_codewords(Œ£::AbstractArray, n::Int, d::Int; m::Int = 10, m_random::Int = 1000) -&gt;
    Codewords{M}
get_codewords(
    Œ£::AbstractArray,
    q::Int,
    n::Int,
    d::Int,
    ùí∞::AbstractArray;
    m::Int = 10,
    m_random::Int = 1000,
) -&gt; Codewords{M}</code></pre><p>Use function <code>get_codewords_random</code> <code>m</code> many times (with <code>get_codewords_random(..., m = m_random)</code>), and <code>get_codewords_greedy</code>.  Return the code with the greatest number of words.  The alphabet will be uniquely generated if none is given.  You can omit Œ£ and ùí∞.  You can omit q if Œ£ is given.</p><p>Parameters:</p><ul><li><code>Œ£::AbstractArray</code>: The alphabet allowed.</li><li><code>q::Int</code>: The size of the alphabet.</li><li><code>n::Int</code>: The (fixed) length of the words in the code.</li><li><code>d::Int</code>: The minimum distance between words in the code.</li><li><code>ùí∞::AbstractArray</code>: The universe of all codewords of q many letters of block length n.</li><li><code>m::Int</code> (kwarg): Try a random code m many times.</li><li><code>m_random::Int</code> (kwarg): The number of possible words <code>get_codewords_random</code> chooses from for <em>each</em> word it selects.</li></ul><p>Returns:</p><ul><li><code>Codewords{M}</code>: An array of codewords, each of length <code>M</code>.  Each codewords is a tuple, and each character in said word is a symbol.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><em>If you are looking for a <em>maximal</em> code, this is likely the function you need.</em>  Increasing <code>m</code> and <code>m_random</code> arbitrarily should ensure a maximal code‚Äî<em>however</em>, that computing power/time in not always possible, as it requires a lot of RAM to store certain codes in memeory.  Efforts are being made to make this process better by using memory-mapped filed instead of storing codewords in RAM, but this will make it much slower as well.  Help with this would be much appreciated.</p></div></div><ul><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; get_codewords([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], 3, 2) # get codewords of block length 3 with distance 2.  Once again, are symbols for uniqueness
9-element Array{Tuple{Symbol,Symbol,Symbol},1}:
 (:a, :b, :a)
 (:c, :a, :b)
 (:b, :c, :c)
 (:b, :a, :a)
 (:c, :b, :c)
 (:a, :a, :c)
 (:a, :c, :b)
 (:c, :c, :a)
 (:b, :b, :b)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/messages.jl#L301-L362">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.get_codewords_greedy-Tuple{UniverseParameters, Int64}" href="#CodingTheory.get_codewords_greedy-Tuple{UniverseParameters, Int64}"><code>CodingTheory.get_codewords_greedy</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_codewords_greedy(ùí∞::UniverseParameters, d::Int) -&gt; Codewords{M}
get_codewords_greedy(Œ£::Alphabet{N}, q::Int, n::Int, d::Int) -&gt; Codewords{M}
get_codewords_greedy(Œ£::Alphabet{N}, n::Int, d::Int) -&gt; Codewords{M}
get_codewords_greedy(q::Int, n::Int, d::Int) -&gt; Codewords{M}
get_codewords_greedy(Œ£::AbstractArray, q::Int, n::Int, d::Int) -&gt; Codewords{M}
get_codewords_greedy(Œ£::AbstractArray, n::Int, d::Int) -&gt; Codewords{M}
get_codewords_greedy(Œ£::AbstractArray, q::Int, n::Int, d::Int, ùí∞::AbstractArray) -&gt;
    Codewords{M}</code></pre><p>Search through the universe of all codewords and find a code of block length n and distance d, using the alphabet Œ£.  The alphabet will be uniquely generated if none is given.  This uses a greedy algorithm, simply iterating through all words (see above) and choosing them if they fit in the code.  In some cases the greedy algorithm is the best, but in others it is very much not.</p><p>Parameters:</p><ul><li><code>ùí∞::UniverseParameters</code>: The parameters of the universe of all codewords of q many letters of block length n.</li><li><code>Œ£::AbstractArray</code>: The alphabet allowed.</li><li><code>q::Int</code>: The size of the alphabet.</li><li><code>n::Int</code>: The (fixed) length of the words in the code.</li><li><code>d::Int</code>: The minimum distance between words in the code.</li></ul><p>Returns:</p><ul><li><code>Codewords{M}</code>: An array of codewords, each of length <code>M</code>.  Each codewords is a tuple, and each character in said word is a symbol.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/messages.jl#L130-L155">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.get_codewords_random-Tuple{UniverseParameters, Int64}" href="#CodingTheory.get_codewords_random-Tuple{UniverseParameters, Int64}"><code>CodingTheory.get_codewords_random</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">get_codewords_random(ùí∞::UniverseParameters, d::Int; m::Int = 1000) -&gt; Codewords{M}
get_codewords_random(Œ£::Alphabet{N}, q::Int, n::Int, d::Int; m::Int = 1000) -&gt; Codewords{M}
get_codewords_random(Œ£::Alphabet{N}, n::Int, d::Int; m::Int = 1000) -&gt; Codewords{M}
get_codewords_random(q::Int, n::Int, d::Int; m::Int = 1000) -&gt; Codewords{M}
get_codewords_random(Œ£::AbstractArray, q::Int, n::Int, d::Int; m::Int = 1000) -&gt;
    Codewords{M}
get_codewords_random(Œ£::AbstractArray, n::Int, d::Int; m::Int = 1000) -&gt; Codewords{M}
get_codewords_random(
    Œ£::AbstractArray, q::Int, n::Int, d::Int, ùí∞::AbstractArray; m::Int = 1000
) -&gt; Codewords{M}</code></pre><p>Search through the universe of all codewords at random and find a code of block length n and distance d, using the alphabet Œ£.  The alphabet will be uniquely generated if none is given.  This is a cleverer algorithm than the greedy algorithm.  Increasing the <code>m</code> keyword argument arbitrarily <em>should</em> produce a maximal code, as for each codeword it chooses, it collects a list of <code>m</code> many random words, and chooses the best one from that intermediate list.</p><p>Parameters:</p><ul><li><code>Œ£::AbstractArray</code>: The alphabet allowed.</li><li><code>q::Int</code>: The size of the alphabet.</li><li><code>n::Int</code>: The (fixed) length of the words in the code.</li><li><code>d::Int</code>: The minimum distance between words in the code.</li><li><code>ùí∞::AbstractArray</code>: The universe of all codewords of q many letters of block length n.</li></ul><p>Returns:</p><ul><li><code>Codewords{M}</code>: An array of codewords, each of length <code>M</code>.  Each codewords is a tuple, and each character in said word is a symbol. # get a random word in the code start</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/messages.jl#L197-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.hamming_ball-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T}, Vector{S}, Int64}} where {T&lt;:(AbstractWord), S}" href="#CodingTheory.hamming_ball-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T}, Vector{S}, Int64}} where {T&lt;:(AbstractWord), S}"><code>CodingTheory.hamming_ball</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hamming_ball(Œ£‚Åø::AbstractArray, w::Vector, e::Int) -&gt; Vector{Vector}</code></pre><p>Get the codewords of radius <span>$e$</span> of a ball centered at word <span>$w$</span>.  That is, all words whose distance from w is less than or equal to the radius.</p><p>Parameters:</p><ul><li><code>Œ£‚Åø::AbstractArray</code>: An array of words in the code.</li><li><code>w::Vector</code>: A word.</li><li><code>e::Int</code>: The radius of the ball.</li></ul><p>Returns:</p><ul><li><p>AbstractArray: The list of words in Œ£‚Åø whose distance from w is less than or equal to e.  Returns an array of array of symbols.</p></li><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; hamming_ball([[1, 0, 1], [0, 1, 1], [1, 0, 0]], [1, 0, 0], 2) # given a list of words, a word, and a distance e (respectively), calculate all the words in the alphabet within distance e of that word.  Converts to symbols in order to keep unique lengths
2-element Array{Any,1}:
 [Symbol(&quot;1&quot;), Symbol(&quot;0&quot;), Symbol(&quot;1&quot;)]
 [Symbol(&quot;1&quot;), Symbol(&quot;0&quot;), Symbol(&quot;0&quot;)]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/distance.jl#L51-L78">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.hamming_distance-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractWord)" href="#CodingTheory.hamming_distance-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractWord)"><code>CodingTheory.hamming_distance</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hamming_distance(w‚ÇÅ, w‚ÇÇ) -&gt; Int</code></pre><p>The Hamming distance of two words is the number of changes that need to be made to each letter in the word for the words to be the same.  This does not work for words of unequal length.</p><p>Parameters:</p><ul><li><code>w‚ÇÅ</code>: A word.</li><li><code>w‚ÇÇ</code>: Another word.</li></ul><p>Returns:</p><ul><li><p><code>Int</code>: the number of changes needing to be made to one word for it to be identical to the other.</p></li><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; hamming_distance(&quot;ABC&quot;, &quot;BBC&quot;) # computes the hamming distance
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/distance.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.hamming_sphere-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T}, Vector{S}, Int64}} where {T&lt;:(AbstractWord), S}" href="#CodingTheory.hamming_sphere-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T}, Vector{S}, Int64}} where {T&lt;:(AbstractWord), S}"><code>CodingTheory.hamming_sphere</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hamming_sphere(Œ£‚Åø::AbstractArray, w::Vector, e::Int) -&gt; Vector{Vector}</code></pre><p>Get the codewords of radius e of a sohere centered at word w.  That is, all words whose distance from w is exactly equal to to the radius.</p><p>Parameters:</p><ul><li><code>Œ£‚Åø::AbstractArray</code>: An array of words in the code.</li><li><code>w::Vector</code>: A word.</li><li><code>e::Int</code>: The radius of the ball.</li></ul><p>Returns:</p><ul><li><code>AbstractArray</code>: The list of words in Œ£‚Åø whose distance from w is exactly equal to e.  Returns an array of array of symbols.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/distance.jl#L82-L98">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.has_identity-Tuple{Matrix}" href="#CodingTheory.has_identity-Tuple{Matrix}"><code>CodingTheory.has_identity</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_identity(M::Matrix) -&gt; Bool
has_identity(M::Matrix, n::Integer) -&gt; Bool</code></pre><p>Checks if a matrix has an identity in it.  If given a number <code>n</code>, the function will specifically check if it has an identity matrix <em>of size n</em> in <code>M</code>.</p><p>See <code>CodingTheory._has_identity</code> for more information.</p><ul><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; A = [1 0 0 2 3 0; 0 1 0 1 2 2; 0 0 1 4 3 0]
3√ó6 Array{Int64,2}:
 1  0  0  2  3  0
 0  1  0  1  2  2
 0  0  1  4  3  0

julia&gt; B = [1 0 1 2 3 0; 0 1 0 1 2 2; 0 0 1 4 3 0]
3√ó6 Array{Int64,2}:
 1  0  1  2  3  0
 0  1  0  1  2  2
 0  0  1  4  3  0

julia&gt; C = [-96 -66 20 1 0 0; -65 59 -82 0 1 0; -16 87 -113 0 0 1]
3√ó6 Array{Int64,2}:
-96  -66    20  1  0  0
-65   59   -82  0  1  0
-16   87  -113  0  0  1

julia&gt; D = [
           78 -99 125 -123 -111 -71 17
           -115 78 40 -88 81 -40 78
           -99 126 -54 1 0 0 24
           -55 88 42 0 1 0 -8
           119 55 2 0 0 1 -92
           -40 -21 -89 -79 59 -44 9
       ]
6√ó7 Array{Int64,2}:
   78  -99  125  -123  -111  -71   17
 -115   78   40   -88    81  -40   78
  -99  126  -54     1     0    0   24
  -55   88   42     0     1    0   -8
  119   55    2     0     0    1  -92
  -40  -21  -89   -79    59  -44    9

julia&gt; has_identity(A)
true

julia&gt; has_identity(B)
true

julia&gt; has_identity(B, 3) # no identity matrix of size 3 exists
false

julia&gt; has_identity(C)
true

julia&gt; has_identity(D)
true

julia&gt; has_identity(D, 4)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L184-L251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.has_identity_on_left-Tuple{Matrix}" href="#CodingTheory.has_identity_on_left-Tuple{Matrix}"><code>CodingTheory.has_identity_on_left</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">has_identity_on_left(M::Matrix) -&gt; Bool</code></pre><p>Checks if the left-hand side of a matrix contains an identity matrix.</p><ul><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; A = [1 0 0 2 3 0; 0 1 0 1 2 2; 0 0 1 4 3 0]
3√ó6 Array{Int64,2}:
 1  0  0  2  3  0
 0  1  0  1  2  2
 0  0  1  4  3  0

julia&gt; B = [-96 -66 20 1 0 0; -65 59 -82 0 1 0; -16 87 -113 0 0 1]
3√ó6 Array{Int64,2}:
 -96  -66    20  1  0  0
 -65   59   -82  0  1  0
 -16   87  -113  0  0  1

julia&gt; has_identity_on_left(A)
true

julia&gt; has_identity_on_left(B)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L255-L285">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.isgolayperfect-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Int64" href="#CodingTheory.isgolayperfect-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Int64"><code>CodingTheory.isgolayperfect</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isgolayperfect(n::Int, k::Int, d::Int, q::Int) -&gt; Bool</code></pre><p>Golay found two perfect codes.  <code>isgolayperfect</code> checks if a code of block length n, distance d, alphabet size q, and dimension k, is a perfect code as described by Golay.</p><p>Parameters:</p><ul><li><code>n::Int</code>: The block length of words in the code (e.g., word &quot;abc&quot; has block length 3).</li><li><code>k::Int</code>: The dimension of the code.</li><li><code>d::Int</code>: The distance of the code (i.e., the minimum distance between codewords in the code).</li><li><code>q::Int</code>: An Int that is a prime power.  The modulus of the finite field.</li></ul><p>Returns:</p><ul><li><p><code>Bool</code>: true or false.</p></li><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; isgolayperfect(11, 6, 5, 3) # this is one of golay&#39;s perfect codes
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/bounds.jl#L336-L362">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.ishammingperfect-Tuple{Int64, Int64}" href="#CodingTheory.ishammingperfect-Tuple{Int64, Int64}"><code>CodingTheory.ishammingperfect</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ishammingbound(r::Int, q::Int) -&gt; Bool</code></pre><p>Checks if the code is a perfect code that is of the form of a generalised Hamming code.</p><p>Parameters:</p><ul><li><code>r::Int</code>: number of rows of a parity check matrix.</li><li><code>q::Int</code>: The size of the alphabet of the code.</li></ul><p>Returns:</p><ul><li><code>Bool</code>: true or false</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/bounds.jl#L249-L264">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.ishammingperfect-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Int64" href="#CodingTheory.ishammingperfect-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Int64"><code>CodingTheory.ishammingperfect</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ishammingperfect(n::Int, k::Int, d::Int, q::Int) -&gt; Bool
ishammingperfect(q::Int, n::Int, d::Int) -&gt; Bool</code></pre><p>Checks if the code is a perfect code that is of the form of a generalised Hamming code.</p><p>Parameters:</p><ul><li><code>q:::Int</code>: The size of the alphabet of the code.</li><li><code>n::Int</code>: The length of the words in the code (block length).</li><li><code>d::Int</code>: The distance of the code.</li><li><code>k::Int</code>: The dimension of the code.</li></ul><p>Returns:</p><ul><li><p><code>Bool</code>: true or false</p></li><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; isgolayperfect(11, 6, 5, 3) # this is one of golay&#39;s perfect codes
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/bounds.jl#L282-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.isincode-Tuple{Vector, AbstractArray{Int64}, Int64}" href="#CodingTheory.isincode-Tuple{Vector, AbstractArray{Int64}, Int64}"><code>CodingTheory.isincode</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isincode(vÃ≤::Vector, H·µÄ::AbstractArray{Int}, n::Int) -&gt; Bool</code></pre><p>If the syndrome of a code is the zero vector, then the word used to calculate the syndrome is in the code.</p><p>Parameters:</p><ul><li><code>vÃ≤::Vector</code>: A word.</li><li><code>H·µÄ::AbstractArray{Int}</code>: The transpose of a parity check matrix.</li></ul><p>Returns:</p><ul><li><code>Bool</code>: If the word is in the code or not (true or false).</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; isincode([0, 2, 1, 2, 0, 1, 0], transpose(parity_check([1 0 0 0 2 2 2; 0 1 0 0 2 0 1; 0 0 1 0 1 0 2; 0 0 0 1 2 2 1], 3)), 3) # tests if the syndrome is equal to the zero vector, and is thus in the code
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L488-L510">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.isirreducible-Tuple{Polynomials.Polynomial, Int64}" href="#CodingTheory.isirreducible-Tuple{Polynomials.Polynomial, Int64}"><code>CodingTheory.isirreducible</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isirreducible(f::AbstractPolynomial, modulo::Int) -&gt; Bool</code></pre><p>Checks if a polynomial is irreducible.</p><p>Parameters:</p><ul><li><code>f::Polynomial</code>: The polynomial you need to check.</li><li><code>modulo::Int</code>: The modulus under which you are working.</li></ul><p>Returns:</p><ul><li><code>Bool</code>: Whether or not the polynomial is irreducible (true or false).</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; isirreducible(Polynomial([1, 1, 0, 0, 1]), 2) # is 1 + x + x^4 mod 2 irreducible?
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L234-L256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.islinear-Tuple{Vector, Int64}" href="#CodingTheory.islinear-Tuple{Vector, Int64}"><code>CodingTheory.islinear</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">islinear(C::Vector, modulo::Int; verbose::Bool = false) -&gt; Bool</code></pre><p>Determines whether a code <code>C</code> is a linear code (i.e., if it is closed under addition, scalar multiplication, and has the zero vector in it).</p><p>Parameters:</p><ul><li><code>C::Vector</code>: A code, typically consisting of multiple vectors or strings.</li><li><code>modulo::Int</code>: The modulus of the field under which you are working.</li><li><code>verbose::Bool</code> (kwarg): print the point at which C fails, if it does.</li></ul><p>Returns:</p><ul><li><code>Bool</code>: Whether or not the code <code>C</code> is linear (true or false).</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">
julia&gt; islinear([[0,0,0],[1,1,1],[1,0,1],[1,1,0]], 2) # checks whether a vector of vectors is linear/a subspace (modulo 2)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L175-L199">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.isperfect-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Int64" href="#CodingTheory.isperfect-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Int64"><code>CodingTheory.isperfect</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isperfect(n::Int, k::Int, d::Int, q::Int) -&gt; Bool</code></pre><p>Checks if a code is perfect.  That is, checks if the number of words in the code is exactly the &quot;Hamming bound&quot;, or the &quot;Sphere Packing Bound&quot;.</p><p>Parameters:</p><ul><li><code>q:::Int</code>: The size of the alphabet of the code.</li><li><code>n::Int</code>: The length of the words in the code (block length).</li><li><code>d::Int</code>: The distance of the code.</li><li><code>k::Int</code>: The dimension of the code.</li></ul><p>Returns:</p><ul><li><p><code>Bool</code>: true or false</p></li><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; isperfect(11, 6, 5, 3)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/bounds.jl#L213-L239">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.isperfectpower-Tuple{Integer}" href="#CodingTheory.isperfectpower-Tuple{Integer}"><code>CodingTheory.isperfectpower</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isperfectpower(n::Integer) -&gt; Bool</code></pre><p>Given an integer <code>n</code>, returns <code>true</code> or <code>false</code> depending on whether or not it is a perfect power.</p><p>Here, a perfect power is some number of the form <span>$a^b$</span>, where <span>$a, b \in \mathbb{N}$</span>, and <span>$b &gt; 1$</span>.</p><p>This function is a wrapper around <a href="https://github.com/thofma/Hecke.jl/blob/master/src/Misc/Integer.jl#L413-L443">Hecke.jl&#39;s really excellent and efficient <code>ispower</code> function</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It should be noted that there is another defintion for &quot;perfect powers&quot;: 	&gt; some number of the form <span>$p^b$</span>, where <span>$p, b \in \mathbb{N}$</span>, <em>and <span>$p$</span> is a prime number``</em>. Here, we call numbers of this form <em>prime powers</em>, or <em>proper perfect powers</em>.  By this definition, 36 is <em>not</em> a perfect power, because 6 is not prime.</p></div></div><p>See also: <code>CodingTheory.isperfectpower</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/powers.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.isprimepower-Tuple{Integer}" href="#CodingTheory.isprimepower-Tuple{Integer}"><code>CodingTheory.isprimepower</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isprimepower(n::Integer) -&gt; Bool</code></pre><p>Given an integer <code>n</code>, returns <code>true</code> or <code>false</code> depending on whether or not it is a prime power.</p><p>A prime power is some number of the form <span>$p^b$</span>, where <span>$p, b \in \mathbb{N}$</span>, and <span>$p$</span> is a prime number``.</p><p>This function is a wrapper around <a href="https://github.com/thofma/Hecke.jl/blob/master/src/Misc/Integer.jl#L756-L769">Hecke.jl&#39;s really excellent and effcient <code>ispower</code> function</a>.</p><p>See also: <code>CodingTheory.isperfectpower</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/powers.jl#L28-L40">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.levenshtein-Tuple{AbstractString, AbstractString}" href="#CodingTheory.levenshtein-Tuple{AbstractString, AbstractString}"><code>CodingTheory.levenshtein</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">levenshtein(source::AbstractString, target::AbstractString) -&gt; Integer
levenshtein(source::AbstractString, target::AbstractString, cost::Real) -&gt; Integer
levenshtein(
    source::AbstractString,
    target::AbstractString,
    deletion_cost::R,
    insertion_cost::S,
    substitution_cost::T,
) -&gt; Integer
levenshtein!(
    source::AbstractString,
    target::AbstractString,
    deletion_cost::R,
    insertion_cost::S,
    substitution_cost::T;
    costs::Matrix = Array{promote_type(R, S, T)}(undef, 2, length(target) + 1),
) -&gt; Integer</code></pre><p>Computes the Levenshtein distance.</p><p><em>These methods are adapted from Levenshtein.jl, by Roger Tu.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/levenshtein.jl#L3-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.list_polys-Tuple{Int64, Int64}" href="#CodingTheory.list_polys-Tuple{Int64, Int64}"><code>CodingTheory.list_polys</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">list_polys(n::Int, m::Int) -&gt; Array</code></pre><p>Lists all polynomials of degree less than to <code>n</code> under modulo <code>m</code>.</p><p>Parameters:</p><ul><li><code>n::Int</code>: Highest degree of polynomial.</li><li><code>m::Int</code>: The modulus of the field.</li></ul><p>Returns:</p><ul><li><code>Array</code>: An array of polynomials of degree less than n, under modulo m.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L58-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.list_span-Tuple" href="#CodingTheory.list_span-Tuple"><code>CodingTheory.list_span</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">list_span(uÃ≤::Vector, vÃ≤::Vector,... modulo::Int) -&gt; Array</code></pre><p>Given any number of vectors <code>uÃ≤</code>, <code>vÃ≤</code>,... , prints all linear combinations of those vectors, modulo <code>modulo</code>.</p><p>Parameters:</p><ul><li><code>uÃ≤::Vector</code>: One vector.</li><li><code>vÃ≤::Vector</code>: Another vector.</li><li><code>...</code>: Other vectors.</li><li><code>modulo::Int</code>: The modulus of the field.</li></ul><p>Returns:</p><ul><li><code>Array</code>: All vectors in the span of uÃ≤ and vÃ≤, under modulo.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; list_span([2, 1, 1], [1, 1, 1], 3) # list the span of two vectors modulo 3
9-element Array{Array{T,1} where T,1}:
 [0, 0, 0]
 [1, 1, 1]
 [2, 2, 2]
 [2, 1, 1]
 [0, 2, 2]
 [1, 0, 0]
 [1, 2, 2]
 [2, 0, 0]
 [0, 1, 1]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L139-L172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.multiplication_table-Tuple{Int64, Int64}" href="#CodingTheory.multiplication_table-Tuple{Int64, Int64}"><code>CodingTheory.multiplication_table</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">multiplication_table(degree::Int, modulo::Int) -&gt; Matrix</code></pre><p>Returns a table (matrix) of the multiplication of all combinations of polynomials for degree less than <code>degree</code>, under modulo <code>modulo</code>.</p><p>Parameters:</p><ul><li><code>degree::Int</code>: Highest degree of polynomial.</li><li><code>modulo::Int</code>: The modulus of the field.</li></ul><p>Returns:</p><ul><li><code>Matrix</code>: A multiplication table of all polynomials with degree less than n, under modulus.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; julia&gt; multiplication_table(2, 3) # multiplication table of all polynomials of degree less than 3 modulo 2
9√ó9 Array{Polynomial,2}:
 Polynomial(0)  Polynomial(0)        Polynomial(0)        ‚Ä¶  Polynomial(0)                Polynomial(0)
 Polynomial(0)  Polynomial(1)        Polynomial(2)           Polynomial(1 + 2*x)          Polynomial(2 + 2*x)
 Polynomial(0)  Polynomial(2)        Polynomial(1)           Polynomial(2 + x)            Polynomial(1 + x)
 Polynomial(0)  Polynomial(x)        Polynomial(2*x)         Polynomial(x + 2*x^2)        Polynomial(2*x + 2*x^2)
 Polynomial(0)  Polynomial(1 + x)    Polynomial(2 + 2*x)     Polynomial(1 + 2*x^2)        Polynomial(2 + x + 2*x^2)
 Polynomial(0)  Polynomial(2 + x)    Polynomial(1 + 2*x)  ‚Ä¶  Polynomial(2 + 2*x + 2*x^2)  Polynomial(1 + 2*x^2)
 Polynomial(0)  Polynomial(2*x)      Polynomial(x)           Polynomial(2*x + x^2)        Polynomial(x + x^2)
 Polynomial(0)  Polynomial(1 + 2*x)  Polynomial(2 + x)       Polynomial(1 + x + x^2)      Polynomial(2 + x^2)
 Polynomial(0)  Polynomial(2 + 2*x)  Polynomial(1 + x)       Polynomial(2 + x^2)          Polynomial(1 + 2*x + x^2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L77-L108">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.mutate_codeword-Union{Tuple{N}, Tuple{T}, Tuple{Union{AbstractVector{T}, AbstractString, NTuple{N, T}}, Int64, T}} where {T, N}" href="#CodingTheory.mutate_codeword-Union{Tuple{N}, Tuple{T}, Tuple{Union{AbstractVector{T}, AbstractString, NTuple{N, T}}, Int64, T}} where {T, N}"><code>CodingTheory.mutate_codeword</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutate_codeword(w::NonStaticAbstractWord{N, T}, n::Int, i::Int, a::T) where {T, N} -&gt;
    MVector{N, T}
mutate_codeword(w::Word{N, T}, n::Int, i::Int, a::T) where {T, N} -&gt; MVector{N, T}</code></pre><p>Mutates the word w, which is an <code>MVector</code> of length N, changing its i·µó ∞ index to a.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/messages.jl#L75-L83">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.normal_form!-Tuple{AbstractArray{Int64}, Int64}" href="#CodingTheory.normal_form!-Tuple{AbstractArray{Int64}, Int64}"><code>CodingTheory.normal_form!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal_form!(M::AbstractArray{Int}, n::Int) -&gt; Matrix{Int}</code></pre><p>Convert a matrix M into normal form under modulo n via Gauss-Jordan elimination.  <em>This directly changes the matrix M.  Use <code>normal_form</code> for a non-mutating version of this function.</em></p><p>Parameters:</p><ul><li><code>M::AbstractArray{Int}</code>: A matrix of Ints.</li><li><code>n::Int</code>: The modulus of the finite field.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: A matrix in normal form from Gauss-Jordan elimination.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">
julia&gt; normal_form!([1 2 0 1 2 1 2; 2 2 2 0 1 1 1; 1 0 1 1 2 1 2; 0 1 0 1 1 2 2], 3) # computes rref colswap = false
4√ó7 Array{Int64,2}:
1  0  0  0  2  2  2
0  1  0  0  2  0  1
0  0  1  0  1  0  2
0  0  0  1  2  2  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L269-L296">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.normal_form-Tuple{AbstractArray{Int64}, Int64}" href="#CodingTheory.normal_form-Tuple{AbstractArray{Int64}, Int64}"><code>CodingTheory.normal_form</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normal_form(M::AbstractArray{Int}, n::Int) -&gt; Matrix{Int}</code></pre><p>Convert a matrix M into normal form under modulo n via Gauss-Jordan elimination.</p><p>Parameters:</p><ul><li><code>M::AbstractArray{Int}</code>: A matrix of Ints.</li><li><code>n::Int</code>: The modulus of the finite field.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: A matrix in normal form from Gauss-Jordan elimination.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">
julia&gt; normal_form([1 2 0 1 2 1 2; 2 2 2 0 1 1 1; 1 0 1 1 2 1 2; 0 1 0 1 1 2 2], 3) # computes rref colswap = false
4√ó7 Array{Int64,2}:
1  0  0  0  2  2  2
0  1  0  0  2  0  1
0  0  1  0  1  0  2
0  0  0  1  2  2  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L301-L328">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.parity_check-Tuple{AbstractArray{Int64}, Int64}" href="#CodingTheory.parity_check-Tuple{AbstractArray{Int64}, Int64}"><code>CodingTheory.parity_check</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">parity_check(M::AbstractArray{Int}, n::Int) -&gt; Matrix{Int}</code></pre><p>Constructs a parity check matrix.  This is calculated from taking the non-identity part of a matrix in normal form (or equivalent &amp;mdash; see <code>generator</code>), transposing it, multiplying it by negative one, and appending to it an appropriate sized identity matrix.</p><p>Parameters:</p><ul><li><code>M::AbstractArray{Int}</code>: A matrix of Ints.</li><li><code>n::Int</code>: The modulus of the finite field.</li></ul><p>Returns:</p><ul><li><code>Matrix{Int}</code>: A parity check matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L434-L447">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.push_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T}, T, Int64}} where T&lt;:(AbstractWord)" href="#CodingTheory.push_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T}, T, Int64}} where T&lt;:(AbstractWord)"><code>CodingTheory.push_if_allowed!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">push_if_allowed!(C::AbstractArray{T}, w::T, d::Int)</code></pre><p>Takes in an array and a word.  As long as the word does not mean that the distance is smaller than d, we add w to the array.  If we are successful in doing this, return true.  Otherwise, return false.  <em>This is a mutating function.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/messages.jl#L4-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.push_if_allowed!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, T, Int64}} where T&lt;:(AbstractWord)" href="#CodingTheory.push_if_allowed!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, T, Int64}} where T&lt;:(AbstractWord)"><code>CodingTheory.push_if_allowed!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">push_if_allowed!(C::AbstractArray{T}, C‚Ä≤::AbstractArray{T}, w::T, d::Int)</code></pre><p>Takes in two arrays, A and B.  If w is allowed in C given distance d, push to C‚Ä≤.  If we are successful in doing this, return true.  Otherwise, return false.  <em>This is a mutating function.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/messages.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.rate-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Integer" href="#CodingTheory.rate-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Integer"><code>CodingTheory.rate</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rate(q::Integer, M::Integer, n::Integer) -&gt; Real</code></pre><p>Calculate the rate of a code.  That is, how efficient the code is.</p><p>Parameters:</p><ul><li><code>q::Integer</code>: the number of symbols in the code.</li><li><code>M::Integer</code>: the size/number of elements in the code.</li><li><code>n::Integer</code>: The word length.</li></ul><p>Returns:</p><ul><li><p><code>Real</code>: Rate of the code.</p></li><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; rate(3, 5, 4) # the rate of the code which has 3 symbols, 5 words in the code, and word length of 4 (e.g., Œ£ = {A, B, C}, C = {ABBA,CABA,BBBB,CAAB,ACBB})
0.3662433801794817</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/bounds.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.replace_if_allowed!-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64, Pair}} where T&lt;:(AbstractWord)" href="#CodingTheory.replace_if_allowed!-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64, Pair}} where T&lt;:(AbstractWord)"><code>CodingTheory.replace_if_allowed!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">replace_if_allowed!(C::AbstractArray, d::Int, w, w‚Ä≤) -&gt; Bool</code></pre><p>Takes in an array and a word.  As long as the word does not mean that the distance is smaller than d, we replace a with b in the array.  Replaces and returns true if allowed; otherwise returns false.  <em>This is a mutating function.</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/messages.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.rref!-Tuple{Matrix{Int64}, Int64}" href="#CodingTheory.rref!-Tuple{Matrix{Int64}, Int64}"><code>CodingTheory.rref!</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rref!(
    A::Matrix{Int},
    n::Int;
    colswap::Bool = false,
    verbose::Bool = false,
    vverbose::Bool = false,
) -&gt; Matrix{Int}</code></pre><p>Performs Gauss-Jordan Elimination on a matrix <code>A</code>.  <em>This directly changes the matrix A.  Use <code>rref</code> for a non-mutating version of this function.</em></p><p>Parameters:</p><ul><li><code>A::Matrix{Int}</code>: A matrix of Ints you wish to perform Gauss-Jordan elimiation on.</li><li><code>n::Int</code>: The modulus of the finite field you are working under.</li><li><code>colswap::Bool</code> (kwarg): Whether or not you allow for column swapping.</li><li><code>verbose::Bool</code> (kwarg): Print the row operations.</li><li><code>vverbose::Bool</code> (kwarg): Print the intermediate matrices of the algorithm.</li></ul><p>Returns:</p><ul><li><p><code>Matrix{Int}</code>: a matrix in row echelon form.</p></li><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; rref!([1 1 0 2 3 1; 2 0 1 3 4 1; 1 2 2 1 4 3], 5; colswap = true) # gauss-jordan elimitation modulo 5 with column swapping
3√ó6 Array{Int64,2}:
 1  0  0  3  2  2
 0  1  0  2  1  1
 0  0  1  0  0  4</code></pre><pre><code class="nohighlight hljs">    # Rule 1: Swap zero rows if out of order and ensure leading ones cascade down diagonally.</code></pre><p>```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/rref.jl#L21-L58">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.rref-Tuple{Matrix{Int64}, Int64}" href="#CodingTheory.rref-Tuple{Matrix{Int64}, Int64}"><code>CodingTheory.rref</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rref(
    A::Matrix{Int},
    n::Int;
    colswap::Bool = false,
    verbose::Bool = false,
    vverbose::Bool = false,
) -&gt; Matrix{Int}</code></pre><p>Performs Gauss-Jordan Elimination on a matrix <code>A</code>.</p><p>Parameters:</p><ul><li><code>A::Matrix{Int}</code>: A matrix of Ints you wish to perform Gauss-Jordan elimiation on.</li><li><code>n::Int</code>: The modulus of the finite field you are working under.</li><li><code>colswap::Bool</code> (kwarg): Whether or not you allow for column swapping.</li><li><code>verbose::Bool</code> (kwarg): Print the row operations.</li><li><code>vverbose::Bool</code> (kwarg): Print the intermediate matrices of the algorithm.</li></ul><p>Returns:</p><ul><li><p><code>Matrix{Int}</code>: a matrix in row echelon form.</p></li><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; rref([1 1 0 2 3 1; 2 0 1 3 4 1; 1 2 2 1 4 3], 5; colswap = true) # gauss-jordan elimitation modulo 5 with column swapping
3√ó6 Array{Int64,2}:
 1  0  0  3  2  2
 0  1  0  2  1  1
 0  0  1  0  0  4</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/rref.jl#L146-L182">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.sizeof_all_words-Tuple{Int64, Int64}" href="#CodingTheory.sizeof_all_words-Tuple{Int64, Int64}"><code>CodingTheory.sizeof_all_words</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sizeof_all_words(q::Number, n::Number) -&gt; Number</code></pre><p>Calculates the number of gigabytes required to store all unique words of length n from an alphabet of size q.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L303-L309">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.sizeof_perfect_code-Tuple{Int64, Int64, Int64}" href="#CodingTheory.sizeof_perfect_code-Tuple{Int64, Int64, Int64}"><code>CodingTheory.sizeof_perfect_code</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sizeof_perfect_code(q::Number, n::Number, d::Number) -&gt; Number</code></pre><p>Calculates the number of gigabytes required to store a perfect code of parameters q, n, and d.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/utils.jl#L289-L295">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.sphere_covering_bound-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Integer" href="#CodingTheory.sphere_covering_bound-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Integer"><code>CodingTheory.sphere_covering_bound</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sphere_covering_bound(q::Integer, n::Integer, d::Integer) -&gt; Integer</code></pre><p>Computes the sphere covering bound of a <span>$[n, d]_q$</span>-code.</p><p>Parameters:</p><ul><li><code>q::Integer</code>: the number of symbols in the code.</li><li><code>n::Integer</code>: the word length.</li><li><code>d::Integer</code>: the distance of the code.</li></ul><p>Returns:</p><ul><li><p><code>Integer</code>: the sphere covering bound.</p></li><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; sphere_covering_bound(5, 7, 3)
215</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/bounds.jl#L36-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.sphere_packing_bound-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Integer" href="#CodingTheory.sphere_packing_bound-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Integer"><code>CodingTheory.sphere_packing_bound</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sphere_packing_bound(q::Integer, n::Integer, d::Integer) -&gt; Integer
sphere_packing_bound(q::Integer, n::Integer, d::Integer, ::Rounding) -&gt; Real</code></pre><p>Computes the sphere packing bound of a <span>$[n, d]_q$</span>-code.  The sphere packing bound is also known as the hamming bound.  You can use <code>hamming_bound</code> to compute the same thing.</p><p>Parameters:</p><ul><li><code>q::Integer</code>: the number of symbols in the code.</li><li><code>n::Integer</code>: the word length.</li><li><code>d::Integer</code>: the distance of the code.</li><li><code>::Rounding</code>: use the argument <code>no_round</code> in this position to preserve the rounding of the code ‚Äî which usually by default rounds down.</li></ul><p>Returns:</p><ul><li><p><code>Integer</code>: the sphere packing bound.</p></li><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; sphere_packing_bound(5, 7, 3)
2693</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/bounds.jl#L65-L92">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.syndrome-Tuple{Vector, AbstractArray{Int64}, Int64}" href="#CodingTheory.syndrome-Tuple{Vector, AbstractArray{Int64}, Int64}"><code>CodingTheory.syndrome</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">syndrome(vÃ≤::Vector, H·µÄ::AbstractArray{Int}, n::Int) -&gt; Matrix{Int}</code></pre><p>Calculates the syndrome of a given word vÃ≤ and a parity check matrix, transposed (H·µÄ), under modulo n.</p><p>Parameters:</p><ul><li><code>vÃ≤::Vector</code>: A word in the code.</li><li><code>H·µÄ::AbstractArray{Int}</code>: The transpose of a parity check matrix.</li></ul><p>Returns:</p><ul><li><code>Vector</code>: The syndrome of a word in the code.</li></ul><hr/><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; syndrome([0, 2, 1, 2, 0, 1, 0], [1 1 1; 1 0 2; 2 0 1; 1 1 2; 1 0 0; 0 1 0; 0 0 1], 3)
1√ó3 Array{Int64,2}:
0  0  0

julia&gt; syndrome([0, 2, 1, 2, 0, 1, 0], transpose(parity_check([1 0 0 0 2 2 2; 0 1 0 0 2 0 1; 0 0 1 0 1 0 2; 0 0 0 1 2 2 1], 3)), 3)
1√ó3 Array{Int64,2}:
 0  0  0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/algebra.jl#L456-L483">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.t_error_correcting-Union{Tuple{T}, Tuple{AbstractArray{T}, Int64}} where T&lt;:Union{AbstractString, Word, AbstractArray{Int64}, AbstractVector, NTuple{N, T} where {N, T}}" href="#CodingTheory.t_error_correcting-Union{Tuple{T}, Tuple{AbstractArray{T}, Int64}} where T&lt;:Union{AbstractString, Word, AbstractArray{Int64}, AbstractVector, NTuple{N, T} where {N, T}}"><code>CodingTheory.t_error_correcting</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">t_error_correcting(C::AbstractArray{T}, t::Int) -&gt; Bool</code></pre><p>Check if a given code C can correct t many errors.</p><p>Parameters:</p><ul><li><code>C::AbstractArray</code>: An array of words in the code.</li><li><code>t::Int</code>: The number of errors you want to check that the code can correct.</li></ul><p>Returns:</p><ul><li>Bool: Yes, C can correct t errors, or no it cannot (true of false).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/distance.jl#L216-L231">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="CodingTheory.t_error_detecting-Union{Tuple{T}, Tuple{AbstractArray{T}, Int64}} where T&lt;:Union{AbstractString, Word, AbstractArray{Int64}, AbstractVector, NTuple{N, T} where {N, T}}" href="#CodingTheory.t_error_detecting-Union{Tuple{T}, Tuple{AbstractArray{T}, Int64}} where T&lt;:Union{AbstractString, Word, AbstractArray{Int64}, AbstractVector, NTuple{N, T} where {N, T}}"><code>CodingTheory.t_error_detecting</code></a> ‚Äî <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">t_error_detecting(C::AbstractArray{T}, t::Int) -&gt; Bool</code></pre><p>Check if a given code C can detect t many errors.</p><p>Parameters:</p><ul><li><code>C::AbstractArray</code>: An array of words in the code.</li><li><code>t::Int</code>: The number of errors you want to check that the code can detect.</li></ul><p>Returns:</p><ul><li><p><code>Bool</code>: Yes, C can detect t errors, or no it cannot (true of false).</p></li><li><ul><li><ul><li></li></ul></li></ul></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; t_error_detecting([[1, 0, 1], [0, 1, 1], [1, 0, 0]], 3)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jakewilliami/CodingTheory.jl/blob/d4c8c74d53adfd848eda60c6eb8a70e0eceb79d0/src/distance.jl#L184-L208">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#CodingTheory.AbstractCode"><code>CodingTheory.AbstractCode</code></a></li><li><a href="#CodingTheory.AbstractWord"><code>CodingTheory.AbstractWord</code></a></li><li><a href="#CodingTheory.Alphabet"><code>CodingTheory.Alphabet</code></a></li><li><a href="#CodingTheory.CodeUniverse"><code>CodingTheory.CodeUniverse</code></a></li><li><a href="#CodingTheory.CodeUniverseIterator"><code>CodingTheory.CodeUniverseIterator</code></a></li><li><a href="#CodingTheory.Codewords"><code>CodingTheory.Codewords</code></a></li><li><a href="#CodingTheory.FiniteField"><code>CodingTheory.FiniteField</code></a></li><li><a href="#CodingTheory.FinitePolynomial"><code>CodingTheory.FinitePolynomial</code></a></li><li><a href="#CodingTheory.NonStaticAbstractWord"><code>CodingTheory.NonStaticAbstractWord</code></a></li><li><a href="#CodingTheory.Rounding"><code>CodingTheory.Rounding</code></a></li><li><a href="#CodingTheory.UniverseParameters"><code>CodingTheory.UniverseParameters</code></a></li><li><a href="#CodingTheory.Word"><code>CodingTheory.Word</code></a></li><li><a href="#Polynomials.Polynomial-Union{Tuple{T}, Tuple{N}, Tuple{Union{Vector{T}, NTuple{N, T}}, Int64}} where {N, T}"><code>Polynomials.Polynomial</code></a></li><li><a href="#Base.gensym-Tuple{Int64}"><code>Base.gensym</code></a></li><li><a href="#Base.mod-Tuple{Polynomials.Polynomial, Int64}"><code>Base.mod</code></a></li><li><a href="#Base.rand-Tuple{UniverseParameters, AbstractArray}"><code>Base.rand</code></a></li><li><a href="#CodingTheory._has_identity-Union{Tuple{T}, Tuple{Matrix, Union{AbstractRange{T}, Base.OneTo{T}, T}}} where T&lt;:Integer"><code>CodingTheory._has_identity</code></a></li><li><a href="#CodingTheory.allequal-Union{Tuple{Union{NTuple{N, T}, AbstractArray{T}} where N}, Tuple{T}} where T"><code>CodingTheory.allequal</code></a></li><li><a href="#CodingTheory.allequal_length-Union{Tuple{Union{NTuple{N, T}, AbstractArray{T}} where N}, Tuple{T}} where T"><code>CodingTheory.allequal_length</code></a></li><li><a href="#CodingTheory.aredistinct-Union{Tuple{Union{NTuple{N, T}, AbstractArray{T}} where N}, Tuple{T}} where T"><code>CodingTheory.aredistinct</code></a></li><li><a href="#CodingTheory.areequalto-Union{Tuple{T}, Tuple{Any, Union{NTuple{N, T}, AbstractArray{T}} where N}} where T"><code>CodingTheory.areequalto</code></a></li><li><a href="#CodingTheory.arelessthan-Union{Tuple{T}, Tuple{Number, Union{NTuple{N, T}, AbstractArray{T}} where N}} where T"><code>CodingTheory.arelessthan</code></a></li><li><a href="#CodingTheory.code_distance-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T&lt;:(AbstractWord)"><code>CodingTheory.code_distance</code></a></li><li><a href="#CodingTheory.code_distance-Union{Tuple{T}, Tuple{AbstractArray{T}, T}} where T&lt;:(AbstractWord)"><code>CodingTheory.code_distance</code></a></li><li><a href="#CodingTheory.code_distance!-Union{Tuple{T}, Tuple{AbstractArray{T}, T}} where T&lt;:(AbstractWord)"><code>CodingTheory.code_distance!</code></a></li><li><a href="#CodingTheory.construct_ham_matrix-Tuple{Int64, Int64}"><code>CodingTheory.construct_ham_matrix</code></a></li><li><a href="#CodingTheory.deepeltype-Tuple{Any}"><code>CodingTheory.deepeltype</code></a></li><li><a href="#CodingTheory.deepsym-Tuple{Any}"><code>CodingTheory.deepsym</code></a></li><li><a href="#CodingTheory.displaymatrix-Tuple{AbstractArray}"><code>CodingTheory.displaymatrix</code></a></li><li><a href="#CodingTheory.ensure_symbolic-Tuple{Any}"><code>CodingTheory.ensure_symbolic</code></a></li><li><a href="#CodingTheory.ensure_symbolic!-Tuple{Any}"><code>CodingTheory.ensure_symbolic!</code></a></li><li><a href="#CodingTheory.equivalent_code-Tuple{AbstractArray{Int64}, Int64}"><code>CodingTheory.equivalent_code</code></a></li><li><a href="#CodingTheory.equivalent_code!-Tuple{AbstractArray{Int64}, Int64}"><code>CodingTheory.equivalent_code!</code></a></li><li><a href="#CodingTheory.find_error_correction_max-Union{Tuple{T}, Tuple{AbstractArray{T}, Int64}} where T&lt;:Union{AbstractString, Word, AbstractArray{Int64}, AbstractVector, NTuple{N, T} where {N, T}}"><code>CodingTheory.find_error_correction_max</code></a></li><li><a href="#CodingTheory.find_error_detection_max-Union{Tuple{T}, Tuple{AbstractArray{T}, Int64}} where T&lt;:Union{AbstractString, Word, AbstractArray{Int64}, AbstractVector, NTuple{N, T} where {N, T}}"><code>CodingTheory.find_error_detection_max</code></a></li><li><a href="#CodingTheory.genalphabet-Tuple{Int64}"><code>CodingTheory.genalphabet</code></a></li><li><a href="#CodingTheory.generator-Tuple{AbstractArray{Int64}, Int64}"><code>CodingTheory.generator</code></a></li><li><a href="#CodingTheory.generator!-Tuple{AbstractArray{Int64}, Int64}"><code>CodingTheory.generator!</code></a></li><li><a href="#CodingTheory.get_all_words-Union{Tuple{N}, Tuple{Alphabet{N}, Int64, Int64}} where N"><code>CodingTheory.get_all_words</code></a></li><li><a href="#CodingTheory.get_codewords-Tuple{AbstractArray, Int64}"><code>CodingTheory.get_codewords</code></a></li><li><a href="#CodingTheory.get_codewords-Tuple{UniverseParameters, Int64}"><code>CodingTheory.get_codewords</code></a></li><li><a href="#CodingTheory.get_codewords_greedy-Tuple{UniverseParameters, Int64}"><code>CodingTheory.get_codewords_greedy</code></a></li><li><a href="#CodingTheory.get_codewords_random-Tuple{UniverseParameters, Int64}"><code>CodingTheory.get_codewords_random</code></a></li><li><a href="#CodingTheory.hamming_ball-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T}, Vector{S}, Int64}} where {T&lt;:(AbstractWord), S}"><code>CodingTheory.hamming_ball</code></a></li><li><a href="#CodingTheory.hamming_distance-Union{Tuple{T}, Tuple{T, T}} where T&lt;:(AbstractWord)"><code>CodingTheory.hamming_distance</code></a></li><li><a href="#CodingTheory.hamming_sphere-Union{Tuple{S}, Tuple{T}, Tuple{AbstractArray{T}, Vector{S}, Int64}} where {T&lt;:(AbstractWord), S}"><code>CodingTheory.hamming_sphere</code></a></li><li><a href="#CodingTheory.has_identity-Tuple{Matrix}"><code>CodingTheory.has_identity</code></a></li><li><a href="#CodingTheory.has_identity_on_left-Tuple{Matrix}"><code>CodingTheory.has_identity_on_left</code></a></li><li><a href="#CodingTheory.isgolayperfect-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Int64"><code>CodingTheory.isgolayperfect</code></a></li><li><a href="#CodingTheory.ishammingperfect-Tuple{Int64, Int64}"><code>CodingTheory.ishammingperfect</code></a></li><li><a href="#CodingTheory.ishammingperfect-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Int64"><code>CodingTheory.ishammingperfect</code></a></li><li><a href="#CodingTheory.isincode-Tuple{Vector, AbstractArray{Int64}, Int64}"><code>CodingTheory.isincode</code></a></li><li><a href="#CodingTheory.isirreducible-Tuple{Polynomials.Polynomial, Int64}"><code>CodingTheory.isirreducible</code></a></li><li><a href="#CodingTheory.islinear-Tuple{Vector, Int64}"><code>CodingTheory.islinear</code></a></li><li><a href="#CodingTheory.isperfect-Union{Tuple{T}, NTuple{4, T}} where T&lt;:Int64"><code>CodingTheory.isperfect</code></a></li><li><a href="#CodingTheory.isperfectpower-Tuple{Integer}"><code>CodingTheory.isperfectpower</code></a></li><li><a href="#CodingTheory.isprimepower-Tuple{Integer}"><code>CodingTheory.isprimepower</code></a></li><li><a href="#CodingTheory.levenshtein-Tuple{AbstractString, AbstractString}"><code>CodingTheory.levenshtein</code></a></li><li><a href="#CodingTheory.list_polys-Tuple{Int64, Int64}"><code>CodingTheory.list_polys</code></a></li><li><a href="#CodingTheory.list_span-Tuple"><code>CodingTheory.list_span</code></a></li><li><a href="#CodingTheory.multiplication_table-Tuple{Int64, Int64}"><code>CodingTheory.multiplication_table</code></a></li><li><a href="#CodingTheory.mutate_codeword-Union{Tuple{N}, Tuple{T}, Tuple{Union{AbstractVector{T}, AbstractString, NTuple{N, T}}, Int64, T}} where {T, N}"><code>CodingTheory.mutate_codeword</code></a></li><li><a href="#CodingTheory.normal_form-Tuple{AbstractArray{Int64}, Int64}"><code>CodingTheory.normal_form</code></a></li><li><a href="#CodingTheory.normal_form!-Tuple{AbstractArray{Int64}, Int64}"><code>CodingTheory.normal_form!</code></a></li><li><a href="#CodingTheory.parity_check-Tuple{AbstractArray{Int64}, Int64}"><code>CodingTheory.parity_check</code></a></li><li><a href="#CodingTheory.push_if_allowed!-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractVector{T}, T, Int64}} where T&lt;:(AbstractWord)"><code>CodingTheory.push_if_allowed!</code></a></li><li><a href="#CodingTheory.push_if_allowed!-Union{Tuple{T}, Tuple{AbstractArray{T}, T, Int64}} where T&lt;:(AbstractWord)"><code>CodingTheory.push_if_allowed!</code></a></li><li><a href="#CodingTheory.rate-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Integer"><code>CodingTheory.rate</code></a></li><li><a href="#CodingTheory.replace_if_allowed!-Union{Tuple{T}, Tuple{AbstractVector{T}, Int64, Pair}} where T&lt;:(AbstractWord)"><code>CodingTheory.replace_if_allowed!</code></a></li><li><a href="#CodingTheory.rref-Tuple{Matrix{Int64}, Int64}"><code>CodingTheory.rref</code></a></li><li><a href="#CodingTheory.rref!-Tuple{Matrix{Int64}, Int64}"><code>CodingTheory.rref!</code></a></li><li><a href="#CodingTheory.sizeof_all_words-Tuple{Int64, Int64}"><code>CodingTheory.sizeof_all_words</code></a></li><li><a href="#CodingTheory.sizeof_perfect_code-Tuple{Int64, Int64, Int64}"><code>CodingTheory.sizeof_perfect_code</code></a></li><li><a href="#CodingTheory.sphere_covering_bound-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Integer"><code>CodingTheory.sphere_covering_bound</code></a></li><li><a href="#CodingTheory.sphere_packing_bound-Union{Tuple{T}, Tuple{T, T, T}} where T&lt;:Integer"><code>CodingTheory.sphere_packing_bound</code></a></li><li><a href="#CodingTheory.syndrome-Tuple{Vector, AbstractArray{Int64}, Int64}"><code>CodingTheory.syndrome</code></a></li><li><a href="#CodingTheory.t_error_correcting-Union{Tuple{T}, Tuple{AbstractArray{T}, Int64}} where T&lt;:Union{AbstractString, Word, AbstractArray{Int64}, AbstractVector, NTuple{N, T} where {N, T}}"><code>CodingTheory.t_error_correcting</code></a></li><li><a href="#CodingTheory.t_error_detecting-Union{Tuple{T}, Tuple{AbstractArray{T}, Int64}} where T&lt;:Union{AbstractString, Word, AbstractArray{Int64}, AbstractVector, NTuple{N, T} where {N, T}}"><code>CodingTheory.t_error_detecting</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 5 November 2024 08:07">Tuesday 5 November 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
